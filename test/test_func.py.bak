import libcst as cst
import libcst.matchers as m
import torch
import monkeytype
import test_model
import sys
from monkeytype.cli import apply_stub_using_libcst
from monkeytype.cli import get_stub
from collections import namedtuple
from torch import Tensor

from monkeytype.stubs import (
    ExistingAnnotationStrategy,
    Stub,
    build_module_stubs_from_traces,
)

prog="""
def add(a, b):
    if a.sum().item() > 100:
        import sys
        c = print(sys.argv)

    return a + b
"""


jit_prog = open("test_model.py").read()

with monkeytype.trace():

    test_model.add(torch.rand(2,2), torch.rand(2,2))
#i = importlib.import_module("matplotlib.text")


# args = {
#     'config' : monkeytype.config.DefaultConfig(),
#     'module_path': ('test_model', ''),
#     'verbose': False,
#     'limit': 1000000,
#     'disable_type_rewriting': False,
#     'existing_annotation_strategy': ExistingAnnotationStrategy.REPLICATE
# }

Args = namedtuple('Args', ['config', 'module_path', 'verbose', 'limit', 'disable_type_rewriting', 'existing_annotation_strategy', 'sample_count'])
args = Args(monkeytype.config.DefaultConfig(), ('test_model', ''), False, -1, False, ExistingAnnotationStrategy.REPLICATE, False)
stub = get_stub(args, sys.stdout, sys.stderr)

jit_prog = apply_stub_using_libcst(stub.render(), jit_prog, False)



init_tree = cst.parse_module(jit_prog)

fun_defs = m.findall(init_tree, m.FunctionDef(name=cst.Name("add")))
extract_mod = cst.Module(body=[fun_defs[0]])
ext_jit_prog = extract_mod.code


error = (False, -1)
try:
    cu = torch.jit.CompilationUnit(ext_jit_prog, _frames_up=0)
except Exception as e:
    e_str = str(e)
    error=(True, int(e_str[e_str.find("line")+5:e_str.find("\n", e_str.find("line"))]))


print(f"Error:{error}")

COUNTER=0

# def new_func_with_args(args):
#     global COUNTER
#     call_stmt = cst.parse_statement(f"f{COUNTER}(val)")
#     call_expr =  call_stmt.body[0].value
#     call_arg =  call_stmt.body[0].value.args[0]
#     COUNTER += 1
#     return call_stmt.with_deep_changes(call_expr, args=args)

def new_func_with_args(args, returns):
    global COUNTER
    func_suffix = COUNTER
    call_stmt = cst.parse_statement(f"(r1, r2) = f{COUNTER}(val)")
    COUNTER += 1
    call_with_args = m.replace(call_stmt, m.Call(), lambda c, e : c.with_changes(args=args))
    call_with_args_returns = m.replace(call_with_args, m.Tuple(), lambda a, e: a.with_changes(elements=returns))
    return (func_suffix, call_with_args_returns)

    # call_expr = cst.parse_statement("(r1) = f1(arg1)")
    # print(call_expr)
    # exit(0)

ret_stmt = cst.parse_statement("return (a, b, c)")
# print(ret_stmt)
# exit(0)

call_stmt = cst.parse_statement(f"f{COUNTER}(val)")
call_expr =  call_stmt.body[0].value
call_arg =  call_stmt.body[0].value.args[0]
ann_stmt = cst.parse_statement(f"""
@torch.jit.ignore
def ann_func(a):
    pass
""")
ignore_ann = ann_stmt.decorators[0]

# def new_func_with_args_returns(args, returns):

#     call_expr = cst.parse_statement("(r1) = f1(arg1)")
#     print(call_expr)
#     exit(0)


def within_range(item, ranje):
    return ranje.start.line <= item.start.line and item.start.line <= ranje.end.line
def before(item, ranje):
    return item.start.line < ranje.start.line
def after(item, ranje):
    return item.start.line > ranje.end.line

class NameCollector(cst.CSTTransformer):
    METADATA_DEPENDENCIES = (cst.metadata.ScopeProvider, cst.metadata.PositionProvider)
    def __init__(self):
        self.names = set()
        self.stack = []
        self.a_nodes = set()
        self.cur_block = None
        self.block_with_error = None
        self.access_in_block_with_error = []
        self.line_with_error = None
        self.funcs = []
    
    # def on_visit(self, node):
    #     if isinstance(node, cst.Name):
    #         #print(node.value)
    #         self.names.add(node.value)
    #     return True

    # def visit_Import(self, node):
    #     pos = self.get_metadata(cst.metadata.PositionProvider, node)
    #     print("start=", pos.start)
    #     print("end=", pos.end)
    #     if error[0]:
    #         self.block_with_error = self.cur_block
    #         print("setting block with error to ", id(self.cur_block))


    def visit_SimpleStatementLine(self, node):
        pos = self.get_metadata(cst.metadata.PositionProvider, node)
        print("visit visit_SimpleStatementLine ", id(node), " at ", pos.start.line)
        print("start=", pos.start)
        print("end=", pos.end)
        if error[0] and error[1] == pos.start.line:
            self.block_with_error = self.cur_block
            self.line_with_error = node
            print("setting block with error to ", id(self.cur_block))

    def visit_IndentedBlock(self, node):
        func_scope = self.get_metadata(cst.metadata.ScopeProvider, node)
        pos = self.get_metadata(cst.metadata.PositionProvider, node)
        self.cur_block = node
        print("visit Idented block ", id(node), " at ", pos.start.line)
        self.stack.append(node)
        for assgn in func_scope.assignments:
            print("assgn: ", assgn.name)
            for ref in assgn.references:
                pos = self.get_metadata(cst.metadata.PositionProvider, ref.node)
                print("access at ", pos.start.line)

        # if (pos.start.line <= error[1] and error[1] <= pos.end.line):
        #     print("found block")

        # for acc in func_scope.accesses:
        #     if acc.node.value == "a":
        #         print("adding a", id(acc.node))
        #         self.a_nodes.add(acc.node)



    def leave_IndentedBlock(self, old_node, new_node):
        if old_node == self.block_with_error:
            func_scope = self.get_metadata(cst.metadata.ScopeProvider, old_node)
            pos = self.get_metadata(cst.metadata.PositionProvider, old_node)



            assign_names = set()
            for assgn in func_scope.assignments:
                print("assgn: ", assgn.name)
                assgn_pos = self.get_metadata(cst.metadata.PositionProvider, assgn.node)
                if within_range(assgn_pos, pos):
                    assign_names.add(assgn.name)
                       
                    # print("access at ", ref_pos.start.line)
                    # if pos.start.line <= ref_pos.start.line and    ref_pos.start.line <= pos.end.line:
                    #     print("capture ref ", ref.node.value)
                    #     arg_names.add(ref.node.value)

            arg_names = set()
            for acc in func_scope.accesses:
                acc_pos = self.get_metadata(cst.metadata.PositionProvider, acc.node)
                print(f"{acc.node} at {acc_pos.start.line}")

                if within_range(acc_pos, pos):
                    if len(acc.referents) == 1:
                        if hasattr(list(acc.referents)[0], "node"):
                            assgn_node = list(acc.referents)[0].node
                            acc_assgn_pos = self.get_metadata(cst.metadata.PositionProvider, assgn_node)
                            if within_range(acc_assgn_pos, pos):
                                continue

                        if isinstance(list(acc.referents)[0], cst.metadata.BuiltinAssignment):
                            continue

                        print(f"needs to be captured: {acc.node} at {acc_pos.start.line}")
                        arg_names.add(acc.node.value)
                
                # for ass in acc.references:
                #     ass_pos = self.get_metadata(cst.metadata.PositionProvider, ass.node)
                #     if within_range(ass_pos, pos):
                #         print(f"variable {acc.node.value} is withing range")
                #         redefined_inside = True
                #     else:
                #         defined_outside = True

            args = []
            for n in arg_names:
                new_arg = call_arg.with_changes(value=cst.Name(n))
                args.append(new_arg)

            returns = []
            for n in assign_names:
                returns.append(cst.Element(value=cst.Name(value=n)))
            func_suffix, func_body = new_func_with_args(args, returns)

            func_ret_stmt = m.replace(ret_stmt, m.Tuple(), lambda a, e: a.with_changes(elements=returns))
            old_body_ret = cst.IndentedBlock(body=list(old_node.body) + [func_ret_stmt])
            self.funcs.append((func_suffix, old_body_ret, arg_names))
            return new_node.with_changes(body=[func_body])
            # print ("leave stack.size ", len(self.stack))
            # if (self.stack[0] != old_node):
            #     print("returning inner block")
            #     return new_node

        return new_node


    # def on_visit(self, node):
    #     if isinstance(node, cst.Name):
    #         #print(node.value)
    #         self.names.add(node.value)
    #     return True

    # def visit_Name(self, node):
    #     if node.value == "a":
    #         print("adding a", id(node))
    #         self.a_nodes.add(node)

    # def leave_Name(self, old_node, new_node):
    #     if old_node in self.a_nodes:
    #         print("replacing ", id(old_node))
    #         return  call_stmt.deep_clone()
    #     return new_node

    # def leave_IndentedBlock(self, old_node, new_node):
    #     print ("leave stack.size ", len(self.stack))
    #     if (self.stack[0] != old_node):
    #         print("returning inner block")
    #         return new_node

        
    #     func_scope = self.get_metadata(cst.metadata.ScopeProvider, new_node)
    #     for assgn in func_scope.assignments:
    #         print(assgn.name)

    #     print ("old_node id = ", id(old_node))
    #     print ("new_node id = ", id(new_node))
    #     print("Accesses:")
    #     for acc in func_scope.accesses:
    #         if (acc.node.value == "a"):
    #             print("in a")
    #             new_node = new_node.with_deep_changes(acc.node, value="a2")
    #         print(acc.node, " ", id(acc.node))
    #     return new_node

    def visit_FunctionDef(self, node):
        return True
        # print ("Hello!")
        # func_scope = self.get_metadata(cst.metadata.ScopeProvider, node.body)
        # for assgn in func_scope.assignments:
        #     print(assgn.name, " ", assgn.node)
        # print("Accesses:")
        # for acc in func_scope.accesses:
        #     print(acc.node)
        # return True

# exec(error_exec)

#libcst.

#assignments
#accesses

tree = cst.parse_module(ext_jit_prog)
wrapper = cst.MetadataWrapper(tree)
nc = NameCollector()
out = wrapper.visit(nc)
helper_defs = [cst.FunctionDef(name=cst.Name(f"f{x[0]}"), decorators=[ignore_ann], body=x[1], params=cst.Parameters(params=[cst.Param(cst.Name(value=y)) for y in x[2]])) for x in nc.funcs]
out = cst.Module(body=helper_defs + list(out.body))
#print(out)
# print(nc.names)

#cu = torch.jit.CompilationUnit(out.code, _frames_up=0)

    # source_with_types = apply_stub_using_libcst(
    #     stub=stub.render(),
    #     source=source_path.read_text(),

t2 = open("test_model2.py", "w")
t2.write('import torch\n')
t2.write('from torch import Tensor\n')
t2.write(out.code)
t2.close()

import test_model2
with monkeytype.trace():
    test_model2.add(torch.rand(2, 2) * 10000, torch.rand(2,2) * 10000)

args2 = Args(monkeytype.config.DefaultConfig(), ('test_model2', ''), False, -1, False, ExistingAnnotationStrategy.REPLICATE, False)
stub = get_stub(args2, sys.stdout, sys.stderr)
jit_prog = apply_stub_using_libcst(stub.render(), out.code, True)
print(jit_prog)
t2 = open("test_model2.py", "w")
t2.write(jit_prog)
t2.close()


print("done!")
torch.jit.script(test_model2.add)
