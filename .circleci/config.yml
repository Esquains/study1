
docker_config_defaults: &docker_config_defaults
  user: jenkins
  aws_auth:
    # This IAM user only allows read-write access to ECR
    aws_access_key_id: ${CIRCLECI_AWS_ACCESS_KEY_FOR_ECR_READ_WRITE_V4}
    aws_secret_access_key: ${CIRCLECI_AWS_SECRET_KEY_FOR_ECR_READ_WRITE_V4}

# This system setup script is meant to run before the CI-related scripts, e.g.,
# installing Git client, checking out code, setting up CI env, and
# building/testing.
setup_linux_system_environment: &setup_linux_system_environment
  name: Set Up System Environment
  no_output_timeout: "1h"
  command: ~/workspace/.circleci/scripts/setup_linux_system_environment.sh

setup_ci_environment: &setup_ci_environment
  name: Set Up CI Environment After attach_workspace
  no_output_timeout: "1h"
  command: ~/workspace/.circleci/scripts/setup_ci_environment.sh


##############################################################################
# Linux build defaults
##############################################################################

pytorch_linux_build_defaults: &pytorch_linux_build_defaults
  resource_class: large
  machine:
    image: ubuntu-1604:201903-01
  steps:
  # See Note [Workspace for CircleCI scripts] in job-specs-setup.yml
  - attach_workspace:
      at: ~/workspace
  - run:
      <<: *setup_linux_system_environment
  - checkout
  - run:
      <<: *setup_ci_environment
  - run:
      name: Build
      no_output_timeout: "1h"
      command: |
        set -e
        # Pull Docker image and run build
        echo "DOCKER_IMAGE: "${DOCKER_IMAGE}
        docker pull ${DOCKER_IMAGE} >/dev/null
        export id=$(docker run -t -d -w /var/lib/jenkins ${DOCKER_IMAGE})

        git submodule sync && git submodule update -q --init --recursive

        docker cp /home/circleci/project/. $id:/var/lib/jenkins/workspace

        if [[ ${BUILD_ENVIRONMENT} == *"namedtensor"* ]]; then
          NAMED_FLAG="export USE_NAMEDTENSOR=1"
        fi

        export COMMAND='((echo "export BUILD_ENVIRONMENT=${BUILD_ENVIRONMENT}" && echo '"$NAMED_FLAG"' && echo "source ./workspace/env" && echo "sudo chown -R jenkins workspace && cd workspace && .jenkins/pytorch/build.sh") | docker exec -u jenkins -i "$id" bash) 2>&1'
        echo ${COMMAND} > ./command.sh && unbuffer bash ./command.sh | ts

        # Push intermediate Docker image for next phase to use
        if [ -z "${BUILD_ONLY}" ]; then
          # Note [namedtensor build image]
          # The namedtensor build uses the same docker image as
          # pytorch-linux-trusty-py3.6-gcc5.4-build. In the push step, we have to
          # distinguish between these two so the test can pick up the correct image.
          output_image=${DOCKER_IMAGE}-${CIRCLE_SHA1}
          if [[ ${BUILD_ENVIRONMENT} == *"namedtensor"* ]]; then
            export COMMIT_DOCKER_IMAGE=$output_image-namedtensor
          else
            export COMMIT_DOCKER_IMAGE=$output_image
          fi
          docker commit "$id" ${COMMIT_DOCKER_IMAGE}
          docker push ${COMMIT_DOCKER_IMAGE}
        fi

pytorch_linux_test_defaults: &pytorch_linux_test_defaults
  machine:
    image: ubuntu-1604:201903-01
  steps:
  # See Note [Workspace for CircleCI scripts] in job-specs-setup.yml
  - attach_workspace:
      at: ~/workspace
  - run:
      <<: *setup_linux_system_environment
  - run:
      <<: *setup_ci_environment
  - run:
      name: Test
      no_output_timeout: "90m"
      command: |
        set -e
        # See Note [namedtensor build image]
        output_image=${DOCKER_IMAGE}-${CIRCLE_SHA1}
        if [[ ${BUILD_ENVIRONMENT} == *"namedtensor"* ]]; then
          export COMMIT_DOCKER_IMAGE=$output_image-namedtensor
          NAMED_FLAG="export USE_NAMEDTENSOR=1"
        else
          export COMMIT_DOCKER_IMAGE=$output_image
        fi
        echo "DOCKER_IMAGE: "${COMMIT_DOCKER_IMAGE}
        docker pull ${COMMIT_DOCKER_IMAGE} >/dev/null
        if [ -n "${USE_CUDA_DOCKER_RUNTIME}" ]; then
          export id=$(docker run --runtime=nvidia -t -d -w /var/lib/jenkins ${COMMIT_DOCKER_IMAGE})
        else
          export id=$(docker run -t -d -w /var/lib/jenkins ${COMMIT_DOCKER_IMAGE})
        fi
        if [ -n "${MULTI_GPU}" ]; then
          export COMMAND='((echo "export BUILD_ENVIRONMENT=${BUILD_ENVIRONMENT}" && echo '"$NAMED_FLAG"' && echo "source ./workspace/env" && echo "sudo chown -R jenkins workspace && cd workspace && .jenkins/pytorch/multigpu-test.sh") | docker exec -u jenkins -i "$id" bash) 2>&1'
        else
          export COMMAND='((echo "export BUILD_ENVIRONMENT=${BUILD_ENVIRONMENT}" && echo '"$NAMED_FLAG"'&& echo "source ./workspace/env" && echo "sudo chown -R jenkins workspace && cd workspace && .jenkins/pytorch/test.sh") | docker exec -u jenkins -i "$id" bash) 2>&1'
        fi
        echo ${COMMAND} > ./command.sh && unbuffer bash ./command.sh | ts


##############################################################################
# Job specifications job specs
##############################################################################
version: 2
jobs:
  pytorch_linux_trusty_py3_6_gcc5_4_build:
    environment:
      BUILD_ENVIRONMENT: pytorch-linux-trusty-py3.6-gcc5.4-build
      DOCKER_IMAGE: "308535385114.dkr.ecr.us-east-1.amazonaws.com/pytorch/pytorch-linux-trusty-py3.6-gcc5.4:300"
    <<: *pytorch_linux_build_defaults

  pytorch_linux_trusty_py3_6_gcc5_4_test:
    environment:
      BUILD_ENVIRONMENT: pytorch-linux-trusty-py3.6-gcc5.4-test
      DOCKER_IMAGE: "308535385114.dkr.ecr.us-east-1.amazonaws.com/pytorch/pytorch-linux-trusty-py3.6-gcc5.4:300"
    resource_class: large
    <<: *pytorch_linux_test_defaults

  
  setup:
    docker:
      - image: circleci/python:3.7.3
    steps:
      - checkout
      - run:
          name: Save commit message
          command: git log --format='%B' -n 1 HEAD > .circleci/scripts/COMMIT_MSG
      # Note [Workspace for CircleCI scripts]
      # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      # In the beginning, you wrote your CI scripts in a
      # .circleci/config.yml file, and life was good.  Your CI
      # configurations flourished and multiplied.
      #
      # Then one day, CircleCI cometh down high and say, "Your YAML file
      # is too biggeth, it stresses our servers so."  And thus they
      # asketh us to smite the scripts in the yml file.
      #
      # But you can't just put the scripts in the .circleci folder,
      # because in some jobs, you don't ever actually checkout the
      # source repository.  Where you gonna get the scripts from?
      #
      # Here's how you do it: you persist .circleci/scripts into a
      # workspace, attach the workspace in your subjobs, and run all
      # your scripts from there.
      - persist_to_workspace:
          root: .
          paths: .circleci/scripts



##############################################################################
##############################################################################
# Workflows
##############################################################################
##############################################################################

# PR jobs pr builds
workflows:
  version: 2
  build:
    jobs:
      - setup
      - pytorch_linux_trusty_py3_6_gcc5_4_build:
          requires:
            - setup
      - pytorch_linux_trusty_py3_6_gcc5_4_test:
          requires:
            - setup
            - pytorch_linux_trusty_py3_6_gcc5_4_build

