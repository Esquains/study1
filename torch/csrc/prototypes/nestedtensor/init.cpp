// THIS CODE IS AUTOGENERATED! DO NOT MODIFY!
// The script is under
// torch/prototypes/nestedtensor/codegen/tensor_list.py
#include <torch/csrc/utils/pybind.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <ATen/ATen.h>

#include <vector>
#include <iostream>

namespace torch {
namespace prototypes {
namespace nestedtensor {
void nestedtensor_abs(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::abs_out(out[i], input1[i]);
  }
}
void nestedtensor_acos(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::acos_out(out[i], input1[i]);
  }
}
void nestedtensor_asin(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::asin_out(out[i], input1[i]);
  }
}
void nestedtensor_atan(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::atan_out(out[i], input1[i]);
  }
}
void nestedtensor_ceil(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::ceil_out(out[i], input1[i]);
  }
}
void nestedtensor_clamp(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::clamp_out(out[i], input1[i]);
  }
}
void nestedtensor_cos(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::cos_out(out[i], input1[i]);
  }
}
void nestedtensor_cosh(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::cosh_out(out[i], input1[i]);
  }
}
void nestedtensor_digamma(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::digamma_out(out[i], input1[i]);
  }
}
void nestedtensor_erf(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::erf_out(out[i], input1[i]);
  }
}
void nestedtensor_erfc(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::erfc_out(out[i], input1[i]);
  }
}
void nestedtensor_erfinv(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::erfinv_out(out[i], input1[i]);
  }
}
void nestedtensor_exp(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::exp_out(out[i], input1[i]);
  }
}
void nestedtensor_expm1(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::expm1_out(out[i], input1[i]);
  }
}
void nestedtensor_floor(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::floor_out(out[i], input1[i]);
  }
}
void nestedtensor_frac(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::frac_out(out[i], input1[i]);
  }
}
void nestedtensor_lgamma(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::lgamma_out(out[i], input1[i]);
  }
}
void nestedtensor_log(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::log_out(out[i], input1[i]);
  }
}
void nestedtensor_log10(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::log10_out(out[i], input1[i]);
  }
}
void nestedtensor_log1p(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::log1p_out(out[i], input1[i]);
  }
}
void nestedtensor_log2(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::log2_out(out[i], input1[i]);
  }
}
void nestedtensor_neg(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::neg_out(out[i], input1[i]);
  }
}
void nestedtensor_nonzero(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::nonzero_out(out[i], input1[i]);
  }
}
void nestedtensor_reciprocal(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::reciprocal_out(out[i], input1[i]);
  }
}
void nestedtensor_round(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::round_out(out[i], input1[i]);
  }
}
void nestedtensor_rsqrt(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::rsqrt_out(out[i], input1[i]);
  }
}
void nestedtensor_sigmoid(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::sigmoid_out(out[i], input1[i]);
  }
}
void nestedtensor_sign(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::sign_out(out[i], input1[i]);
  }
}
void nestedtensor_sin(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::sin_out(out[i], input1[i]);
  }
}
void nestedtensor_sinh(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::sinh_out(out[i], input1[i]);
  }
}
void nestedtensor_sqrt(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::sqrt_out(out[i], input1[i]);
  }
}
void nestedtensor_tan(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::tan_out(out[i], input1[i]);
  }
}
void nestedtensor_tanh(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::tanh_out(out[i], input1[i]);
  }
}
void nestedtensor_tril(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::tril_out(out[i], input1[i]);
  }
}
void nestedtensor_triu(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::triu_out(out[i], input1[i]);
  }
}
void nestedtensor_trunc(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::trunc_out(out[i], input1[i]);
  }
}

void nestedtensor_add(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::add_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_mul(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::mul_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_sub(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::sub_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_div(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::div_out(out[i], input1[i], input2[i]);
  }
}

void nestedtensor_eq(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::eq_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_ge(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::ge_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_gt(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::gt_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_le(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::le_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_ne(std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::ne_out(out[i], input1[i], input2[i]);
  }
}

PyObject* nestedtensor_init(PyObject* _unused) {
  C10_LOG_API_USAGE_ONCE("tensor_list.python.import");
  auto nestedtensor_module = THPObjectPtr(PyImport_ImportModule("torch.prototypes.nestedtensor"));
  if (!nestedtensor_module) {
    throw python_error();
  }

  auto m = py::handle(nestedtensor_module).cast<py::module>();
  m.def("abs", &nestedtensor_abs, "abs");
  m.def("acos", &nestedtensor_acos, "acos");
  m.def("asin", &nestedtensor_asin, "asin");
  m.def("atan", &nestedtensor_atan, "atan");
  m.def("ceil", &nestedtensor_ceil, "ceil");
  m.def("clamp", &nestedtensor_clamp, "clamp");
  m.def("cos", &nestedtensor_cos, "cos");
  m.def("cosh", &nestedtensor_cosh, "cosh");
  m.def("digamma", &nestedtensor_digamma, "digamma");
  m.def("erf", &nestedtensor_erf, "erf");
  m.def("erfc", &nestedtensor_erfc, "erfc");
  m.def("erfinv", &nestedtensor_erfinv, "erfinv");
  m.def("exp", &nestedtensor_exp, "exp");
  m.def("expm1", &nestedtensor_expm1, "expm1");
  m.def("floor", &nestedtensor_floor, "floor");
  m.def("frac", &nestedtensor_frac, "frac");
  m.def("lgamma", &nestedtensor_lgamma, "lgamma");
  m.def("log", &nestedtensor_log, "log");
  m.def("log10", &nestedtensor_log10, "log10");
  m.def("log1p", &nestedtensor_log1p, "log1p");
  m.def("log2", &nestedtensor_log2, "log2");
  m.def("neg", &nestedtensor_neg, "neg");
  m.def("nonzero", &nestedtensor_nonzero, "nonzero");
  m.def("reciprocal", &nestedtensor_reciprocal, "reciprocal");
  m.def("round", &nestedtensor_round, "round");
  m.def("rsqrt", &nestedtensor_rsqrt, "rsqrt");
  m.def("sigmoid", &nestedtensor_sigmoid, "sigmoid");
  m.def("sign", &nestedtensor_sign, "sign");
  m.def("sin", &nestedtensor_sin, "sin");
  m.def("sinh", &nestedtensor_sinh, "sinh");
  m.def("sqrt", &nestedtensor_sqrt, "sqrt");
  m.def("tan", &nestedtensor_tan, "tan");
  m.def("tanh", &nestedtensor_tanh, "tanh");
  m.def("tril", &nestedtensor_tril, "tril");
  m.def("triu", &nestedtensor_triu, "triu");
  m.def("trunc", &nestedtensor_trunc, "trunc");
  m.def("add", &nestedtensor_add, "add");
  m.def("mul", &nestedtensor_mul, "mul");
  m.def("sub", &nestedtensor_sub, "sub");
  m.def("div", &nestedtensor_div, "div");
  m.def("eq", &nestedtensor_eq, "eq");
  m.def("ge", &nestedtensor_ge, "ge");
  m.def("gt", &nestedtensor_gt, "gt");
  m.def("le", &nestedtensor_le, "le");
  m.def("ne", &nestedtensor_ne, "ne");

  Py_RETURN_TRUE;
}
// prototypes methods on torch._C
static PyMethodDef methods[] = {
    {"_nestedtensor_init", (PyCFunction)nestedtensor_init, METH_NOARGS, nullptr},
    {nullptr, nullptr, 0, nullptr}};

PyMethodDef* python_functions() {
  return methods;
}

} // namespace nestedtensor
} // namespace prototypes
} // namespace torch
