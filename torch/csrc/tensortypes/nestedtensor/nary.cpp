// THIS CODE IS AUTOGENERATED! DO NOT MODIFY!
// The script is under
// torch/tensortypes/nestedtensor/codegen/nary_gen.py
#include <torch/csrc/utils/pybind.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <ATen/ATen.h>

#include <vector>
#include <iostream>

namespace torch {
namespace tensortypes {
namespace nestedtensor {
void nestedtensor_abs(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::abs_out(out[i], input1[i]);
  }
}
void nestedtensor_acos(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::acos_out(out[i], input1[i]);
  }
}
void nestedtensor_asin(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::asin_out(out[i], input1[i]);
  }
}
void nestedtensor_atan(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::atan_out(out[i], input1[i]);
  }
}
void nestedtensor_ceil(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::ceil_out(out[i], input1[i]);
  }
}
void nestedtensor_clamp(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::clamp_out(out[i], input1[i]);
  }
}
void nestedtensor_cos(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::cos_out(out[i], input1[i]);
  }
}
void nestedtensor_cosh(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::cosh_out(out[i], input1[i]);
  }
}
void nestedtensor_digamma(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::digamma_out(out[i], input1[i]);
  }
}
void nestedtensor_erf(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::erf_out(out[i], input1[i]);
  }
}
void nestedtensor_erfc(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::erfc_out(out[i], input1[i]);
  }
}
void nestedtensor_erfinv(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::erfinv_out(out[i], input1[i]);
  }
}
void nestedtensor_exp(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::exp_out(out[i], input1[i]);
  }
}
void nestedtensor_expm1(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::expm1_out(out[i], input1[i]);
  }
}
void nestedtensor_floor(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::floor_out(out[i], input1[i]);
  }
}
void nestedtensor_frac(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::frac_out(out[i], input1[i]);
  }
}
void nestedtensor_lgamma(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::lgamma_out(out[i], input1[i]);
  }
}
void nestedtensor_log(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::log_out(out[i], input1[i]);
  }
}
void nestedtensor_log10(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::log10_out(out[i], input1[i]);
  }
}
void nestedtensor_log1p(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::log1p_out(out[i], input1[i]);
  }
}
void nestedtensor_log2(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::log2_out(out[i], input1[i]);
  }
}
void nestedtensor_neg(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::neg_out(out[i], input1[i]);
  }
}
void nestedtensor_nonzero(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::nonzero_out(out[i], input1[i]);
  }
}
void nestedtensor_reciprocal(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::reciprocal_out(out[i], input1[i]);
  }
}
void nestedtensor_round(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::round_out(out[i], input1[i]);
  }
}
void nestedtensor_rsqrt(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::rsqrt_out(out[i], input1[i]);
  }
}
void nestedtensor_sigmoid(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::sigmoid_out(out[i], input1[i]);
  }
}
void nestedtensor_sign(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::sign_out(out[i], input1[i]);
  }
}
void nestedtensor_sin(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::sin_out(out[i], input1[i]);
  }
}
void nestedtensor_sinh(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::sinh_out(out[i], input1[i]);
  }
}
void nestedtensor_sqrt(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::sqrt_out(out[i], input1[i]);
  }
}
void nestedtensor_tan(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::tan_out(out[i], input1[i]);
  }
}
void nestedtensor_tanh(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::tanh_out(out[i], input1[i]);
  }
}
void nestedtensor_tril(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::tril_out(out[i], input1[i]);
  }
}
void nestedtensor_triu(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::triu_out(out[i], input1[i]);
  }
}
void nestedtensor_trunc(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::trunc_out(out[i], input1[i]);
  }
}

void nestedtensor_add(const std::vector<at::Tensor>& input1,
                       const std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::add_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_mul(const std::vector<at::Tensor>& input1,
                       const std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::mul_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_sub(const std::vector<at::Tensor>& input1,
                       const std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::sub_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_div(const std::vector<at::Tensor>& input1,
                       const std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::div_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_pow(const std::vector<at::Tensor>& input1,
                       const std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::pow_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_atan2(const std::vector<at::Tensor>& input1,
                       const std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::atan2_out(out[i], input1[i], input2[i]);
  }
}

void nestedtensor_eq(const std::vector<at::Tensor>& input1,
                       const std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::eq_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_ge(const std::vector<at::Tensor>& input1,
                       const std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::ge_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_gt(const std::vector<at::Tensor>& input1,
                       const std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::gt_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_le(const std::vector<at::Tensor>& input1,
                       const std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::le_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_ne(const std::vector<at::Tensor>& input1,
                       const std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::ne_out(out[i], input1[i], input2[i]);
  }
}
void nestedtensor_lt(const std::vector<at::Tensor>& input1,
                       const std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::lt_out(out[i], input1[i], input2[i]);
  }
}

void add_nary_functions(py::module& m) {
  m.def("abs", &nestedtensor_abs, "abs");
  m.def("acos", &nestedtensor_acos, "acos");
  m.def("asin", &nestedtensor_asin, "asin");
  m.def("atan", &nestedtensor_atan, "atan");
  m.def("ceil", &nestedtensor_ceil, "ceil");
  m.def("clamp", &nestedtensor_clamp, "clamp");
  m.def("cos", &nestedtensor_cos, "cos");
  m.def("cosh", &nestedtensor_cosh, "cosh");
  m.def("digamma", &nestedtensor_digamma, "digamma");
  m.def("erf", &nestedtensor_erf, "erf");
  m.def("erfc", &nestedtensor_erfc, "erfc");
  m.def("erfinv", &nestedtensor_erfinv, "erfinv");
  m.def("exp", &nestedtensor_exp, "exp");
  m.def("expm1", &nestedtensor_expm1, "expm1");
  m.def("floor", &nestedtensor_floor, "floor");
  m.def("frac", &nestedtensor_frac, "frac");
  m.def("lgamma", &nestedtensor_lgamma, "lgamma");
  m.def("log", &nestedtensor_log, "log");
  m.def("log10", &nestedtensor_log10, "log10");
  m.def("log1p", &nestedtensor_log1p, "log1p");
  m.def("log2", &nestedtensor_log2, "log2");
  m.def("neg", &nestedtensor_neg, "neg");
  m.def("nonzero", &nestedtensor_nonzero, "nonzero");
  m.def("reciprocal", &nestedtensor_reciprocal, "reciprocal");
  m.def("round", &nestedtensor_round, "round");
  m.def("rsqrt", &nestedtensor_rsqrt, "rsqrt");
  m.def("sigmoid", &nestedtensor_sigmoid, "sigmoid");
  m.def("sign", &nestedtensor_sign, "sign");
  m.def("sin", &nestedtensor_sin, "sin");
  m.def("sinh", &nestedtensor_sinh, "sinh");
  m.def("sqrt", &nestedtensor_sqrt, "sqrt");
  m.def("tan", &nestedtensor_tan, "tan");
  m.def("tanh", &nestedtensor_tanh, "tanh");
  m.def("tril", &nestedtensor_tril, "tril");
  m.def("triu", &nestedtensor_triu, "triu");
  m.def("trunc", &nestedtensor_trunc, "trunc");
  m.def("add", &nestedtensor_add, "add");
  m.def("mul", &nestedtensor_mul, "mul");
  m.def("sub", &nestedtensor_sub, "sub");
  m.def("div", &nestedtensor_div, "div");
  m.def("pow", &nestedtensor_pow, "pow");
  m.def("atan2", &nestedtensor_atan2, "atan2");
  m.def("eq", &nestedtensor_eq, "eq");
  m.def("ge", &nestedtensor_ge, "ge");
  m.def("gt", &nestedtensor_gt, "gt");
  m.def("le", &nestedtensor_le, "le");
  m.def("ne", &nestedtensor_ne, "ne");
  m.def("lt", &nestedtensor_lt, "lt");

}
} // namespace nestedtensor
} // namespace tensortypes
} // namespace torch
