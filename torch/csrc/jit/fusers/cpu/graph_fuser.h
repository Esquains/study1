#if !(defined _WIN32)
#pragma once

#include "torch/csrc/jit/ir.h"

#include "torch/csrc/WindowsTorchApiMacro.h"

#include "ATen/ATen.h"

#include <unordered_map>

namespace torch { namespace jit { namespace cpufuser {

TORCH_API struct GraphFuser {

  GraphFuser(Block* block): block(block) {}

  void run();

private:
  Block* block;

  // Used to order nodes so we always consider producer-consumer fusions
  // in reverse topological order.
  // If topological_index[a] > topological_index[b] then a occurs after b.
  // Because nodes can be added to this graph during optimization, this mapping is not bijective.
  // Newly generated nodes will copy the location where they are inserted.
  std::unordered_map<Node*,size_t> topological_index;

  at::optional<int> getDevice(Node* node);

  // Returns true if the value is a CPU float tensor, false otherwise
  bool isSupportedValue(Value* val);

  // Returns true if all values are supported, false otherwise
  bool allValuesSupported(at::ArrayRef<Value*> list);

  // Returns true if all values are tensors with the same sizes
  bool areTensorsOfSameShape(at::ArrayRef<Value*> values);

  bool isSupportedNode(Node* node);

  // Returns true if the node is generically supported or a special case
  // False otherwise
  // Special cases:
  //  A CPU Fusion Group
  //  Addition and comparison operators on supported values
  //  type_as when outputting supported values
  bool isFusable(Node* node);

  bool isFusableCatNode(Node* node);

  bool isFusableOnlyAsExitNode(Node* node);

  // Can this node produce an _output_ of a fusion group?
  // all Fusable nodes can do this, but additionally Concat, which normally cannot be fused
  // because it is not a simple map, can be put in a fusion group
  // as long as no items in the group read the output of concat
  bool isFusableAsExitNode(Node* node);

  // necessary condition for fusion. If all of the uses of producer are consumer
  // then it is safe to merge producer into consumer, because it doesn't have any other uses
  // If there are other uses, but they occur _after_ consumer, then we can still merge in producer
  // with consumer, by rewriting those later uses to use the version of producer generated by the fused blob
  // In this case, producer becomes an output of the fusion group.
  bool allUsersAreThisConsumerOrOccurAfterIt(Node* consumer, Value* producer);

  bool allUsersAreThisConsumer(Node* consumer, Value* producer);

  bool mustRemainAsFusionGroupOutput(Value* producer);

  bool shouldFuse(Node* consumer, Value* producer);

  // insert a producer node into a consuming fusion group.
  // DOES NOT WORK if n is a consumer of an output of the fusion group
  // returns the node _inside_ the group that represents the node
  Graph& getSubgraph(Node* n);

  void mergeFusionGroups(Node* consumer_group, Node* producer_group);

  Node* mergeNodeIntoGroup(Node* group, Node* n);

  // turn consumer node n into a fusion group with just n inside
  // to prepare for fusion and replace uses of n with the new group
  Node* createSingletonFusionGroup(Node* n);

  void insertAfter(Node* n, Node* after);

  void insertAt(Node** insertion_point, Node* n);

  Node* fuse(Node* consumer, Value* producer);

  // TODO: desugar chunks into splits and then remove this special case
  bool isChunk(Node* node);

  // in places where op can be fused into a consumer but chunk is in the way
  // distribute chunk to op's operands:
  // replace a,b = chunk(op(x,y,z)) with:
  // x0,x1 = chunk(x) (x0 has a's type, x1 has b's type)
  // y0,y1 = chunk(y) (y0 has a's type, y1 has b's type)
  // z0,z1 = chunk(z) (z0 has a's type, z1 has b's type)
  // a = op(x0,y0,z0) (a,b have their same size but are now contiguous)
  // b = op(x1,y1,x1)
  //
  // NB: Chunk motion only occurs with fusable consumers, which implies
  // that there is always some other operation, e.g., a+b, that happens
  // after the chunk, and will be put into the fusion group. This is
  // important, because distributing the chunk changes the contiguity
  // of a and b, and so the results would be invalid, except that we know
  // that simple_mappable operations will restore contiguity before
  // we exit the fusion group.

  bool tryToMoveChunk(Node* consumer, Value* producer);

  // returns where to continue scanning, and whether any fusion was made
  std::pair<graph_node_list::iterator, bool> scanNode(Node* consumer);
};

} // namespace cpufuser
} // namespace jit
} // namespace torch

#endif // !(defined _WIN32)