// Example IDL file for our monster's schema.

// TODO(gmagogsfm): Update namespace.
namespace torch.jit.mobile.serialization;

struct Int {
  // NOTE: pickler uses hand rolled varint
  int_val:long;
}

struct Bool {
  bool_val:bool;
}

struct Double{
  double_val:double;
}

struct PerTensorAffineSchema {
  q_scale:double;
  q_zero_point:int;
}

table QuantizedSchema {
  qscheme:byte;
  scale: double;
  zero_point: int;
  scales:TensorMetadata;
  zero_points:TensorMetadata;
  axis:int;
}

table TensorMetadata {
  // TODO(quantized?)
  // torch._utils _rebuild_tensor_v2
  storage_location_index:int;
  // enum ScalarType
  scalar_type: byte;
  storage_offset:int;
  nbytes:long;
  element_size:int;
  sizes:[int];
  strides:[int];
  requires_grad:bool;

  // only set for quantized tensors
  quantized_schema:QuantizedSchema;
}

table String {
  data: string;
}

// Is it needed to represent other types?
union IValue {
  Int,
  Bool,
  Double,
  TensorMetadata,
  String,
  List,
  Tuple,
  Dict,
  Object,
  IntList,
  DoubleList,
  BoolList
}

table List {
  items: [IValue];
}

table IntList {
  items: [long];
}

table DoubleList {
  items: [double];
}

table BoolList {
  items: [bool];
}

table Tuple {
  items: [IValue];
}

table Dict {
  keys: [IValue];
  values: [IValue];
}

table ObjectType {
  type_name:string;
  attr_names:[string];
  setattr: Function;
}

table Object {
  type_index: byte;
  attr_names:[string];
  use_setstate:bool;
  state: IValue;
}

struct Instruction {
  // Should op be enum instead?
  op:byte;
  n:ushort;
  x:int;
}

table Operator {
  name:string;
  overload_name:string;
  num_args_serialized:byte= -1;
}

table Arg {
  name:string;
  // Why do we use string to represent types
  // rather than index into Code.types?
  type:string;
  default_value:IValue;  // position into ivalues
}

table Schema {
  arguments:[Arg];
  returns:[Arg];
}

table DebugInfo {
  // put this with instr?
  debug_handle:[long];
}

table Function {
  qn:string;
  instructions:[Instruction];
  operators:[Operator];
  constants:[IValue];

  // index into type table
  types:[ubyte];

  register_size:int;
  schema:Schema;
  debug_info:DebugInfo;
}

table StorageData {
  data: [ubyte] (force_align: 16);
}

table Module {
  methods:[Function];

  types:[ObjectType];  // type information of objects used

  // this is module._ivalue()
  state_obj: Object;

  storage_data: [StorageData];

  storage_data_size:int;  // number of storage data;

  type_annotations:[string];
}

root_type Module;
