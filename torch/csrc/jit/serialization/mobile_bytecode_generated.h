// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MOBILEBYTECODE_TORCH_JIT_MOBILE_SERIALIZATION_H_
#define FLATBUFFERS_GENERATED_MOBILEBYTECODE_TORCH_JIT_MOBILE_SERIALIZATION_H_

#include "flatbuffers/flatbuffers.h"

namespace torch {
namespace jit {
namespace mobile {
namespace serialization {

struct Int;

struct Bool;

struct Double;

struct PerTensorAffineSchema;

struct QuantizedSchema;
struct QuantizedSchemaBuilder;

struct TensorMetadata;
struct TensorMetadataBuilder;

struct String;
struct StringBuilder;

struct List;
struct ListBuilder;

struct IntList;
struct IntListBuilder;

struct DoubleList;
struct DoubleListBuilder;

struct BoolList;
struct BoolListBuilder;

struct Tuple;
struct TupleBuilder;

struct Dict;
struct DictBuilder;

struct ObjectType;
struct ObjectTypeBuilder;

struct Object;
struct ObjectBuilder;

struct Instruction;

struct Operator;
struct OperatorBuilder;

struct Arg;
struct ArgBuilder;

struct Schema;
struct SchemaBuilder;

struct DebugInfo;
struct DebugInfoBuilder;

struct Function;
struct FunctionBuilder;

struct StorageData;
struct StorageDataBuilder;

struct Module;
struct ModuleBuilder;

enum IValue : uint8_t {
  IValue_NONE = 0,
  IValue_Int = 1,
  IValue_Bool = 2,
  IValue_Double = 3,
  IValue_TensorMetadata = 4,
  IValue_String = 5,
  IValue_List = 6,
  IValue_Tuple = 7,
  IValue_Dict = 8,
  IValue_Object = 9,
  IValue_IntList = 10,
  IValue_DoubleList = 11,
  IValue_BoolList = 12,
  IValue_MIN = IValue_NONE,
  IValue_MAX = IValue_BoolList
};

inline const IValue (&EnumValuesIValue())[13] {
  static const IValue values[] = {
    IValue_NONE,
    IValue_Int,
    IValue_Bool,
    IValue_Double,
    IValue_TensorMetadata,
    IValue_String,
    IValue_List,
    IValue_Tuple,
    IValue_Dict,
    IValue_Object,
    IValue_IntList,
    IValue_DoubleList,
    IValue_BoolList
  };
  return values;
}

inline const char * const *EnumNamesIValue() {
  static const char * const names[14] = {
    "NONE",
    "Int",
    "Bool",
    "Double",
    "TensorMetadata",
    "String",
    "List",
    "Tuple",
    "Dict",
    "Object",
    "IntList",
    "DoubleList",
    "BoolList",
    nullptr
  };
  return names;
}

inline const char *EnumNameIValue(IValue e) {
  if (flatbuffers::IsOutRange(e, IValue_NONE, IValue_BoolList)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesIValue()[index];
}

template<typename T> struct IValueTraits {
  static const IValue enum_value = IValue_NONE;
};

template<> struct IValueTraits<torch::jit::mobile::serialization::Int> {
  static const IValue enum_value = IValue_Int;
};

template<> struct IValueTraits<torch::jit::mobile::serialization::Bool> {
  static const IValue enum_value = IValue_Bool;
};

template<> struct IValueTraits<torch::jit::mobile::serialization::Double> {
  static const IValue enum_value = IValue_Double;
};

template<> struct IValueTraits<torch::jit::mobile::serialization::TensorMetadata> {
  static const IValue enum_value = IValue_TensorMetadata;
};

template<> struct IValueTraits<torch::jit::mobile::serialization::String> {
  static const IValue enum_value = IValue_String;
};

template<> struct IValueTraits<torch::jit::mobile::serialization::List> {
  static const IValue enum_value = IValue_List;
};

template<> struct IValueTraits<torch::jit::mobile::serialization::Tuple> {
  static const IValue enum_value = IValue_Tuple;
};

template<> struct IValueTraits<torch::jit::mobile::serialization::Dict> {
  static const IValue enum_value = IValue_Dict;
};

template<> struct IValueTraits<torch::jit::mobile::serialization::Object> {
  static const IValue enum_value = IValue_Object;
};

template<> struct IValueTraits<torch::jit::mobile::serialization::IntList> {
  static const IValue enum_value = IValue_IntList;
};

template<> struct IValueTraits<torch::jit::mobile::serialization::DoubleList> {
  static const IValue enum_value = IValue_DoubleList;
};

template<> struct IValueTraits<torch::jit::mobile::serialization::BoolList> {
  static const IValue enum_value = IValue_BoolList;
};

bool VerifyIValue(flatbuffers::Verifier &verifier, const void *obj, IValue type);
bool VerifyIValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Int FLATBUFFERS_FINAL_CLASS {
 private:
  int64_t int_val_;

 public:
  Int()
      : int_val_(0) {
  }
  Int(int64_t _int_val)
      : int_val_(flatbuffers::EndianScalar(_int_val)) {
  }
  int64_t int_val() const {
    return flatbuffers::EndianScalar(int_val_);
  }
};
FLATBUFFERS_STRUCT_END(Int, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Bool FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t bool_val_;

 public:
  Bool()
      : bool_val_(0) {
  }
  Bool(bool _bool_val)
      : bool_val_(flatbuffers::EndianScalar(static_cast<uint8_t>(_bool_val))) {
  }
  bool bool_val() const {
    return flatbuffers::EndianScalar(bool_val_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(Bool, 1);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Double FLATBUFFERS_FINAL_CLASS {
 private:
  double double_val_;

 public:
  Double()
      : double_val_(0) {
  }
  Double(double _double_val)
      : double_val_(flatbuffers::EndianScalar(_double_val)) {
  }
  double double_val() const {
    return flatbuffers::EndianScalar(double_val_);
  }
};
FLATBUFFERS_STRUCT_END(Double, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) PerTensorAffineSchema FLATBUFFERS_FINAL_CLASS {
 private:
  double q_scale_;
  int32_t q_zero_point_;
  int32_t padding0__;

 public:
  PerTensorAffineSchema()
      : q_scale_(0),
        q_zero_point_(0),
        padding0__(0) {
    (void)padding0__;
  }
  PerTensorAffineSchema(double _q_scale, int32_t _q_zero_point)
      : q_scale_(flatbuffers::EndianScalar(_q_scale)),
        q_zero_point_(flatbuffers::EndianScalar(_q_zero_point)),
        padding0__(0) {
    (void)padding0__;
  }
  double q_scale() const {
    return flatbuffers::EndianScalar(q_scale_);
  }
  int32_t q_zero_point() const {
    return flatbuffers::EndianScalar(q_zero_point_);
  }
};
FLATBUFFERS_STRUCT_END(PerTensorAffineSchema, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Instruction FLATBUFFERS_FINAL_CLASS {
 private:
  int8_t op_;
  int8_t padding0__;
  uint16_t n_;
  int32_t x_;

 public:
  Instruction()
      : op_(0),
        padding0__(0),
        n_(0),
        x_(0) {
    (void)padding0__;
  }
  Instruction(int8_t _op, uint16_t _n, int32_t _x)
      : op_(flatbuffers::EndianScalar(_op)),
        padding0__(0),
        n_(flatbuffers::EndianScalar(_n)),
        x_(flatbuffers::EndianScalar(_x)) {
    (void)padding0__;
  }
  int8_t op() const {
    return flatbuffers::EndianScalar(op_);
  }
  uint16_t n() const {
    return flatbuffers::EndianScalar(n_);
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
};
FLATBUFFERS_STRUCT_END(Instruction, 8);

struct QuantizedSchema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantizedSchemaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QSCHEME = 4,
    VT_SCALE = 6,
    VT_ZERO_POINT = 8,
    VT_SCALES = 10,
    VT_ZERO_POINTS = 12,
    VT_AXIS = 14
  };
  int8_t qscheme() const {
    return GetField<int8_t>(VT_QSCHEME, 0);
  }
  double scale() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  int32_t zero_point() const {
    return GetField<int32_t>(VT_ZERO_POINT, 0);
  }
  const torch::jit::mobile::serialization::TensorMetadata *scales() const {
    return GetPointer<const torch::jit::mobile::serialization::TensorMetadata *>(VT_SCALES);
  }
  const torch::jit::mobile::serialization::TensorMetadata *zero_points() const {
    return GetPointer<const torch::jit::mobile::serialization::TensorMetadata *>(VT_ZERO_POINTS);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_QSCHEME) &&
           VerifyField<double>(verifier, VT_SCALE) &&
           VerifyField<int32_t>(verifier, VT_ZERO_POINT) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyTable(scales()) &&
           VerifyOffset(verifier, VT_ZERO_POINTS) &&
           verifier.VerifyTable(zero_points()) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct QuantizedSchemaBuilder {
  typedef QuantizedSchema Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_qscheme(int8_t qscheme) {
    fbb_.AddElement<int8_t>(QuantizedSchema::VT_QSCHEME, qscheme, 0);
  }
  void add_scale(double scale) {
    fbb_.AddElement<double>(QuantizedSchema::VT_SCALE, scale, 0.0);
  }
  void add_zero_point(int32_t zero_point) {
    fbb_.AddElement<int32_t>(QuantizedSchema::VT_ZERO_POINT, zero_point, 0);
  }
  void add_scales(flatbuffers::Offset<torch::jit::mobile::serialization::TensorMetadata> scales) {
    fbb_.AddOffset(QuantizedSchema::VT_SCALES, scales);
  }
  void add_zero_points(flatbuffers::Offset<torch::jit::mobile::serialization::TensorMetadata> zero_points) {
    fbb_.AddOffset(QuantizedSchema::VT_ZERO_POINTS, zero_points);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(QuantizedSchema::VT_AXIS, axis, 0);
  }
  explicit QuantizedSchemaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuantizedSchema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizedSchema>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizedSchema> CreateQuantizedSchema(
    flatbuffers::FlatBufferBuilder &_fbb,
    int8_t qscheme = 0,
    double scale = 0.0,
    int32_t zero_point = 0,
    flatbuffers::Offset<torch::jit::mobile::serialization::TensorMetadata> scales = 0,
    flatbuffers::Offset<torch::jit::mobile::serialization::TensorMetadata> zero_points = 0,
    int32_t axis = 0) {
  QuantizedSchemaBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_axis(axis);
  builder_.add_zero_points(zero_points);
  builder_.add_scales(scales);
  builder_.add_zero_point(zero_point);
  builder_.add_qscheme(qscheme);
  return builder_.Finish();
}

struct TensorMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STORAGE_LOCATION_INDEX = 4,
    VT_SCALAR_TYPE = 6,
    VT_STORAGE_OFFSET = 8,
    VT_SIZES = 10,
    VT_STRIDES = 12,
    VT_REQUIRES_GRAD = 14,
    VT_QUANTIZED_SCHEMA = 16
  };
  int32_t storage_location_index() const {
    return GetField<int32_t>(VT_STORAGE_LOCATION_INDEX, 0);
  }
  int8_t scalar_type() const {
    return GetField<int8_t>(VT_SCALAR_TYPE, 0);
  }
  int32_t storage_offset() const {
    return GetField<int32_t>(VT_STORAGE_OFFSET, 0);
  }
  const flatbuffers::Vector<int32_t> *sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIZES);
  }
  const flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  bool requires_grad() const {
    return GetField<uint8_t>(VT_REQUIRES_GRAD, 0) != 0;
  }
  const torch::jit::mobile::serialization::QuantizedSchema *quantized_schema() const {
    return GetPointer<const torch::jit::mobile::serialization::QuantizedSchema *>(VT_QUANTIZED_SCHEMA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_STORAGE_LOCATION_INDEX) &&
           VerifyField<int8_t>(verifier, VT_SCALAR_TYPE) &&
           VerifyField<int32_t>(verifier, VT_STORAGE_OFFSET) &&
           VerifyOffset(verifier, VT_SIZES) &&
           verifier.VerifyVector(sizes()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<uint8_t>(verifier, VT_REQUIRES_GRAD) &&
           VerifyOffset(verifier, VT_QUANTIZED_SCHEMA) &&
           verifier.VerifyTable(quantized_schema()) &&
           verifier.EndTable();
  }
};

struct TensorMetadataBuilder {
  typedef TensorMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_storage_location_index(int32_t storage_location_index) {
    fbb_.AddElement<int32_t>(TensorMetadata::VT_STORAGE_LOCATION_INDEX, storage_location_index, 0);
  }
  void add_scalar_type(int8_t scalar_type) {
    fbb_.AddElement<int8_t>(TensorMetadata::VT_SCALAR_TYPE, scalar_type, 0);
  }
  void add_storage_offset(int32_t storage_offset) {
    fbb_.AddElement<int32_t>(TensorMetadata::VT_STORAGE_OFFSET, storage_offset, 0);
  }
  void add_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> sizes) {
    fbb_.AddOffset(TensorMetadata::VT_SIZES, sizes);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(TensorMetadata::VT_STRIDES, strides);
  }
  void add_requires_grad(bool requires_grad) {
    fbb_.AddElement<uint8_t>(TensorMetadata::VT_REQUIRES_GRAD, static_cast<uint8_t>(requires_grad), 0);
  }
  void add_quantized_schema(flatbuffers::Offset<torch::jit::mobile::serialization::QuantizedSchema> quantized_schema) {
    fbb_.AddOffset(TensorMetadata::VT_QUANTIZED_SCHEMA, quantized_schema);
  }
  explicit TensorMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorMetadata> CreateTensorMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t storage_location_index = 0,
    int8_t scalar_type = 0,
    int32_t storage_offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> strides = 0,
    bool requires_grad = false,
    flatbuffers::Offset<torch::jit::mobile::serialization::QuantizedSchema> quantized_schema = 0) {
  TensorMetadataBuilder builder_(_fbb);
  builder_.add_quantized_schema(quantized_schema);
  builder_.add_strides(strides);
  builder_.add_sizes(sizes);
  builder_.add_storage_offset(storage_offset);
  builder_.add_storage_location_index(storage_location_index);
  builder_.add_requires_grad(requires_grad);
  builder_.add_scalar_type(scalar_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorMetadata> CreateTensorMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t storage_location_index = 0,
    int8_t scalar_type = 0,
    int32_t storage_offset = 0,
    const std::vector<int32_t> *sizes = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    bool requires_grad = false,
    flatbuffers::Offset<torch::jit::mobile::serialization::QuantizedSchema> quantized_schema = 0) {
  auto sizes__ = sizes ? _fbb.CreateVector<int32_t>(*sizes) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  return torch::jit::mobile::serialization::CreateTensorMetadata(
      _fbb,
      storage_location_index,
      scalar_type,
      storage_offset,
      sizes__,
      strides__,
      requires_grad,
      quantized_schema);
}

struct String FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           verifier.EndTable();
  }
};

struct StringBuilder {
  typedef String Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(String::VT_DATA, data);
  }
  explicit StringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<String> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<String>(end);
    return o;
  }
};

inline flatbuffers::Offset<String> CreateString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> data = 0) {
  StringBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<String> CreateStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *data = nullptr) {
  auto data__ = data ? _fbb.CreateString(data) : 0;
  return torch::jit::mobile::serialization::CreateString(
      _fbb,
      data__);
}

struct List FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS_TYPE = 4,
    VT_ITEMS = 6
  };
  const flatbuffers::Vector<uint8_t> *items_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ITEMS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS_TYPE) &&
           verifier.VerifyVector(items_type()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           VerifyIValueVector(verifier, items(), items_type()) &&
           verifier.EndTable();
  }
};

struct ListBuilder {
  typedef List Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items_type) {
    fbb_.AddOffset(List::VT_ITEMS_TYPE, items_type);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> items) {
    fbb_.AddOffset(List::VT_ITEMS, items);
  }
  explicit ListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<List> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<List>(end);
    return o;
  }
};

inline flatbuffers::Offset<List> CreateList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> items = 0) {
  ListBuilder builder_(_fbb);
  builder_.add_items(items);
  builder_.add_items_type(items_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<List> CreateListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *items_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *items = nullptr) {
  auto items_type__ = items_type ? _fbb.CreateVector<uint8_t>(*items_type) : 0;
  auto items__ = items ? _fbb.CreateVector<flatbuffers::Offset<void>>(*items) : 0;
  return torch::jit::mobile::serialization::CreateList(
      _fbb,
      items_type__,
      items__);
}

struct IntList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<int64_t> *items() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct IntListBuilder {
  typedef IntList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<int64_t>> items) {
    fbb_.AddOffset(IntList::VT_ITEMS, items);
  }
  explicit IntListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IntList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntList>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntList> CreateIntList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> items = 0) {
  IntListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<IntList> CreateIntListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<int64_t>(*items) : 0;
  return torch::jit::mobile::serialization::CreateIntList(
      _fbb,
      items__);
}

struct DoubleList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DoubleListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<double> *items() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct DoubleListBuilder {
  typedef DoubleList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<double>> items) {
    fbb_.AddOffset(DoubleList::VT_ITEMS, items);
  }
  explicit DoubleListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DoubleList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DoubleList>(end);
    return o;
  }
};

inline flatbuffers::Offset<DoubleList> CreateDoubleList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> items = 0) {
  DoubleListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<DoubleList> CreateDoubleListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<double>(*items) : 0;
  return torch::jit::mobile::serialization::CreateDoubleList(
      _fbb,
      items__);
}

struct BoolList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BoolListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS = 4
  };
  const flatbuffers::Vector<uint8_t> *items() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           verifier.EndTable();
  }
};

struct BoolListBuilder {
  typedef BoolList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items) {
    fbb_.AddOffset(BoolList::VT_ITEMS, items);
  }
  explicit BoolListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BoolList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BoolList>(end);
    return o;
  }
};

inline flatbuffers::Offset<BoolList> CreateBoolList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items = 0) {
  BoolListBuilder builder_(_fbb);
  builder_.add_items(items);
  return builder_.Finish();
}

inline flatbuffers::Offset<BoolList> CreateBoolListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *items = nullptr) {
  auto items__ = items ? _fbb.CreateVector<uint8_t>(*items) : 0;
  return torch::jit::mobile::serialization::CreateBoolList(
      _fbb,
      items__);
}

struct Tuple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TupleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMS_TYPE = 4,
    VT_ITEMS = 6
  };
  const flatbuffers::Vector<uint8_t> *items_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ITEMS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *items() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_ITEMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ITEMS_TYPE) &&
           verifier.VerifyVector(items_type()) &&
           VerifyOffset(verifier, VT_ITEMS) &&
           verifier.VerifyVector(items()) &&
           VerifyIValueVector(verifier, items(), items_type()) &&
           verifier.EndTable();
  }
};

struct TupleBuilder {
  typedef Tuple Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_items_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items_type) {
    fbb_.AddOffset(Tuple::VT_ITEMS_TYPE, items_type);
  }
  void add_items(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> items) {
    fbb_.AddOffset(Tuple::VT_ITEMS, items);
  }
  explicit TupleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Tuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tuple>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tuple> CreateTuple(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> items_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> items = 0) {
  TupleBuilder builder_(_fbb);
  builder_.add_items(items);
  builder_.add_items_type(items_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tuple> CreateTupleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *items_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *items = nullptr) {
  auto items_type__ = items_type ? _fbb.CreateVector<uint8_t>(*items_type) : 0;
  auto items__ = items ? _fbb.CreateVector<flatbuffers::Offset<void>>(*items) : 0;
  return torch::jit::mobile::serialization::CreateTuple(
      _fbb,
      items_type__,
      items__);
}

struct Dict FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DictBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYS_TYPE = 4,
    VT_KEYS = 6,
    VT_VALUES_TYPE = 8,
    VT_VALUES = 10
  };
  const flatbuffers::Vector<uint8_t> *keys_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_KEYS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *keys() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_KEYS);
  }
  const flatbuffers::Vector<uint8_t> *values_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUES_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEYS_TYPE) &&
           verifier.VerifyVector(keys_type()) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.VerifyVector(keys()) &&
           VerifyIValueVector(verifier, keys(), keys_type()) &&
           VerifyOffset(verifier, VT_VALUES_TYPE) &&
           verifier.VerifyVector(values_type()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           VerifyIValueVector(verifier, values(), values_type()) &&
           verifier.EndTable();
  }
};

struct DictBuilder {
  typedef Dict Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keys_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> keys_type) {
    fbb_.AddOffset(Dict::VT_KEYS_TYPE, keys_type);
  }
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> keys) {
    fbb_.AddOffset(Dict::VT_KEYS, keys);
  }
  void add_values_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values_type) {
    fbb_.AddOffset(Dict::VT_VALUES_TYPE, values_type);
  }
  void add_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> values) {
    fbb_.AddOffset(Dict::VT_VALUES, values);
  }
  explicit DictBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Dict> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dict>(end);
    return o;
  }
};

inline flatbuffers::Offset<Dict> CreateDict(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> keys_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> keys = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> values_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> values = 0) {
  DictBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_values_type(values_type);
  builder_.add_keys(keys);
  builder_.add_keys_type(keys_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Dict> CreateDictDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *keys_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *keys = nullptr,
    const std::vector<uint8_t> *values_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *values = nullptr) {
  auto keys_type__ = keys_type ? _fbb.CreateVector<uint8_t>(*keys_type) : 0;
  auto keys__ = keys ? _fbb.CreateVector<flatbuffers::Offset<void>>(*keys) : 0;
  auto values_type__ = values_type ? _fbb.CreateVector<uint8_t>(*values_type) : 0;
  auto values__ = values ? _fbb.CreateVector<flatbuffers::Offset<void>>(*values) : 0;
  return torch::jit::mobile::serialization::CreateDict(
      _fbb,
      keys_type__,
      keys__,
      values_type__,
      values__);
}

struct ObjectType FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectTypeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_NAME = 4,
    VT_ATTR_NAMES = 6,
    VT_SETATTR = 8
  };
  const flatbuffers::String *type_name() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *attr_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ATTR_NAMES);
  }
  const torch::jit::mobile::serialization::Function *setattr() const {
    return GetPointer<const torch::jit::mobile::serialization::Function *>(VT_SETATTR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE_NAME) &&
           verifier.VerifyString(type_name()) &&
           VerifyOffset(verifier, VT_ATTR_NAMES) &&
           verifier.VerifyVector(attr_names()) &&
           verifier.VerifyVectorOfStrings(attr_names()) &&
           VerifyOffset(verifier, VT_SETATTR) &&
           verifier.VerifyTable(setattr()) &&
           verifier.EndTable();
  }
};

struct ObjectTypeBuilder {
  typedef ObjectType Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type_name(flatbuffers::Offset<flatbuffers::String> type_name) {
    fbb_.AddOffset(ObjectType::VT_TYPE_NAME, type_name);
  }
  void add_attr_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> attr_names) {
    fbb_.AddOffset(ObjectType::VT_ATTR_NAMES, attr_names);
  }
  void add_setattr(flatbuffers::Offset<torch::jit::mobile::serialization::Function> setattr) {
    fbb_.AddOffset(ObjectType::VT_SETATTR, setattr);
  }
  explicit ObjectTypeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectType> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectType>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectType> CreateObjectType(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> attr_names = 0,
    flatbuffers::Offset<torch::jit::mobile::serialization::Function> setattr = 0) {
  ObjectTypeBuilder builder_(_fbb);
  builder_.add_setattr(setattr);
  builder_.add_attr_names(attr_names);
  builder_.add_type_name(type_name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObjectType> CreateObjectTypeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type_name = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *attr_names = nullptr,
    flatbuffers::Offset<torch::jit::mobile::serialization::Function> setattr = 0) {
  auto type_name__ = type_name ? _fbb.CreateString(type_name) : 0;
  auto attr_names__ = attr_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*attr_names) : 0;
  return torch::jit::mobile::serialization::CreateObjectType(
      _fbb,
      type_name__,
      attr_names__,
      setattr);
}

struct Object FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_INDEX = 4,
    VT_ATTR_NAMES = 6,
    VT_USE_SETSTATE = 8,
    VT_STATE_TYPE = 10,
    VT_STATE = 12
  };
  uint8_t type_index() const {
    return GetField<uint8_t>(VT_TYPE_INDEX, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *attr_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ATTR_NAMES);
  }
  bool use_setstate() const {
    return GetField<uint8_t>(VT_USE_SETSTATE, 0) != 0;
  }
  torch::jit::mobile::serialization::IValue state_type() const {
    return static_cast<torch::jit::mobile::serialization::IValue>(GetField<uint8_t>(VT_STATE_TYPE, 0));
  }
  const void *state() const {
    return GetPointer<const void *>(VT_STATE);
  }
  template<typename T> const T *state_as() const;
  const torch::jit::mobile::serialization::Int *state_as_Int() const {
    return state_type() == torch::jit::mobile::serialization::IValue_Int ? static_cast<const torch::jit::mobile::serialization::Int *>(state()) : nullptr;
  }
  const torch::jit::mobile::serialization::Bool *state_as_Bool() const {
    return state_type() == torch::jit::mobile::serialization::IValue_Bool ? static_cast<const torch::jit::mobile::serialization::Bool *>(state()) : nullptr;
  }
  const torch::jit::mobile::serialization::Double *state_as_Double() const {
    return state_type() == torch::jit::mobile::serialization::IValue_Double ? static_cast<const torch::jit::mobile::serialization::Double *>(state()) : nullptr;
  }
  const torch::jit::mobile::serialization::TensorMetadata *state_as_TensorMetadata() const {
    return state_type() == torch::jit::mobile::serialization::IValue_TensorMetadata ? static_cast<const torch::jit::mobile::serialization::TensorMetadata *>(state()) : nullptr;
  }
  const torch::jit::mobile::serialization::String *state_as_String() const {
    return state_type() == torch::jit::mobile::serialization::IValue_String ? static_cast<const torch::jit::mobile::serialization::String *>(state()) : nullptr;
  }
  const torch::jit::mobile::serialization::List *state_as_List() const {
    return state_type() == torch::jit::mobile::serialization::IValue_List ? static_cast<const torch::jit::mobile::serialization::List *>(state()) : nullptr;
  }
  const torch::jit::mobile::serialization::Tuple *state_as_Tuple() const {
    return state_type() == torch::jit::mobile::serialization::IValue_Tuple ? static_cast<const torch::jit::mobile::serialization::Tuple *>(state()) : nullptr;
  }
  const torch::jit::mobile::serialization::Dict *state_as_Dict() const {
    return state_type() == torch::jit::mobile::serialization::IValue_Dict ? static_cast<const torch::jit::mobile::serialization::Dict *>(state()) : nullptr;
  }
  const torch::jit::mobile::serialization::Object *state_as_Object() const {
    return state_type() == torch::jit::mobile::serialization::IValue_Object ? static_cast<const torch::jit::mobile::serialization::Object *>(state()) : nullptr;
  }
  const torch::jit::mobile::serialization::IntList *state_as_IntList() const {
    return state_type() == torch::jit::mobile::serialization::IValue_IntList ? static_cast<const torch::jit::mobile::serialization::IntList *>(state()) : nullptr;
  }
  const torch::jit::mobile::serialization::DoubleList *state_as_DoubleList() const {
    return state_type() == torch::jit::mobile::serialization::IValue_DoubleList ? static_cast<const torch::jit::mobile::serialization::DoubleList *>(state()) : nullptr;
  }
  const torch::jit::mobile::serialization::BoolList *state_as_BoolList() const {
    return state_type() == torch::jit::mobile::serialization::IValue_BoolList ? static_cast<const torch::jit::mobile::serialization::BoolList *>(state()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE_INDEX) &&
           VerifyOffset(verifier, VT_ATTR_NAMES) &&
           verifier.VerifyVector(attr_names()) &&
           verifier.VerifyVectorOfStrings(attr_names()) &&
           VerifyField<uint8_t>(verifier, VT_USE_SETSTATE) &&
           VerifyField<uint8_t>(verifier, VT_STATE_TYPE) &&
           VerifyOffset(verifier, VT_STATE) &&
           VerifyIValue(verifier, state(), state_type()) &&
           verifier.EndTable();
  }
};

template<> inline const torch::jit::mobile::serialization::Int *Object::state_as<torch::jit::mobile::serialization::Int>() const {
  return state_as_Int();
}

template<> inline const torch::jit::mobile::serialization::Bool *Object::state_as<torch::jit::mobile::serialization::Bool>() const {
  return state_as_Bool();
}

template<> inline const torch::jit::mobile::serialization::Double *Object::state_as<torch::jit::mobile::serialization::Double>() const {
  return state_as_Double();
}

template<> inline const torch::jit::mobile::serialization::TensorMetadata *Object::state_as<torch::jit::mobile::serialization::TensorMetadata>() const {
  return state_as_TensorMetadata();
}

template<> inline const torch::jit::mobile::serialization::String *Object::state_as<torch::jit::mobile::serialization::String>() const {
  return state_as_String();
}

template<> inline const torch::jit::mobile::serialization::List *Object::state_as<torch::jit::mobile::serialization::List>() const {
  return state_as_List();
}

template<> inline const torch::jit::mobile::serialization::Tuple *Object::state_as<torch::jit::mobile::serialization::Tuple>() const {
  return state_as_Tuple();
}

template<> inline const torch::jit::mobile::serialization::Dict *Object::state_as<torch::jit::mobile::serialization::Dict>() const {
  return state_as_Dict();
}

template<> inline const torch::jit::mobile::serialization::Object *Object::state_as<torch::jit::mobile::serialization::Object>() const {
  return state_as_Object();
}

template<> inline const torch::jit::mobile::serialization::IntList *Object::state_as<torch::jit::mobile::serialization::IntList>() const {
  return state_as_IntList();
}

template<> inline const torch::jit::mobile::serialization::DoubleList *Object::state_as<torch::jit::mobile::serialization::DoubleList>() const {
  return state_as_DoubleList();
}

template<> inline const torch::jit::mobile::serialization::BoolList *Object::state_as<torch::jit::mobile::serialization::BoolList>() const {
  return state_as_BoolList();
}

struct ObjectBuilder {
  typedef Object Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type_index(uint8_t type_index) {
    fbb_.AddElement<uint8_t>(Object::VT_TYPE_INDEX, type_index, 0);
  }
  void add_attr_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> attr_names) {
    fbb_.AddOffset(Object::VT_ATTR_NAMES, attr_names);
  }
  void add_use_setstate(bool use_setstate) {
    fbb_.AddElement<uint8_t>(Object::VT_USE_SETSTATE, static_cast<uint8_t>(use_setstate), 0);
  }
  void add_state_type(torch::jit::mobile::serialization::IValue state_type) {
    fbb_.AddElement<uint8_t>(Object::VT_STATE_TYPE, static_cast<uint8_t>(state_type), 0);
  }
  void add_state(flatbuffers::Offset<void> state) {
    fbb_.AddOffset(Object::VT_STATE, state);
  }
  explicit ObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Object> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Object>(end);
    return o;
  }
};

inline flatbuffers::Offset<Object> CreateObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t type_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> attr_names = 0,
    bool use_setstate = false,
    torch::jit::mobile::serialization::IValue state_type = torch::jit::mobile::serialization::IValue_NONE,
    flatbuffers::Offset<void> state = 0) {
  ObjectBuilder builder_(_fbb);
  builder_.add_state(state);
  builder_.add_attr_names(attr_names);
  builder_.add_state_type(state_type);
  builder_.add_use_setstate(use_setstate);
  builder_.add_type_index(type_index);
  return builder_.Finish();
}

inline flatbuffers::Offset<Object> CreateObjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t type_index = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *attr_names = nullptr,
    bool use_setstate = false,
    torch::jit::mobile::serialization::IValue state_type = torch::jit::mobile::serialization::IValue_NONE,
    flatbuffers::Offset<void> state = 0) {
  auto attr_names__ = attr_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*attr_names) : 0;
  return torch::jit::mobile::serialization::CreateObject(
      _fbb,
      type_index,
      attr_names__,
      use_setstate,
      state_type,
      state);
}

struct Operator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OperatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OVERLOAD_NAME = 6,
    VT_NUM_ARGS_SERIALIZED = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *overload_name() const {
    return GetPointer<const flatbuffers::String *>(VT_OVERLOAD_NAME);
  }
  int32_t num_args_serialized() const {
    return GetField<int32_t>(VT_NUM_ARGS_SERIALIZED, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_OVERLOAD_NAME) &&
           verifier.VerifyString(overload_name()) &&
           VerifyField<int32_t>(verifier, VT_NUM_ARGS_SERIALIZED) &&
           verifier.EndTable();
  }
};

struct OperatorBuilder {
  typedef Operator Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Operator::VT_NAME, name);
  }
  void add_overload_name(flatbuffers::Offset<flatbuffers::String> overload_name) {
    fbb_.AddOffset(Operator::VT_OVERLOAD_NAME, overload_name);
  }
  void add_num_args_serialized(int32_t num_args_serialized) {
    fbb_.AddElement<int32_t>(Operator::VT_NUM_ARGS_SERIALIZED, num_args_serialized, -1);
  }
  explicit OperatorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Operator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline flatbuffers::Offset<Operator> CreateOperator(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> overload_name = 0,
    int32_t num_args_serialized = -1) {
  OperatorBuilder builder_(_fbb);
  builder_.add_num_args_serialized(num_args_serialized);
  builder_.add_overload_name(overload_name);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Operator> CreateOperatorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *overload_name = nullptr,
    int32_t num_args_serialized = -1) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto overload_name__ = overload_name ? _fbb.CreateString(overload_name) : 0;
  return torch::jit::mobile::serialization::CreateOperator(
      _fbb,
      name__,
      overload_name__,
      num_args_serialized);
}

struct Arg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_DEFAULT_VALUE_TYPE = 8,
    VT_DEFAULT_VALUE = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  torch::jit::mobile::serialization::IValue default_value_type() const {
    return static_cast<torch::jit::mobile::serialization::IValue>(GetField<uint8_t>(VT_DEFAULT_VALUE_TYPE, 0));
  }
  const void *default_value() const {
    return GetPointer<const void *>(VT_DEFAULT_VALUE);
  }
  template<typename T> const T *default_value_as() const;
  const torch::jit::mobile::serialization::Int *default_value_as_Int() const {
    return default_value_type() == torch::jit::mobile::serialization::IValue_Int ? static_cast<const torch::jit::mobile::serialization::Int *>(default_value()) : nullptr;
  }
  const torch::jit::mobile::serialization::Bool *default_value_as_Bool() const {
    return default_value_type() == torch::jit::mobile::serialization::IValue_Bool ? static_cast<const torch::jit::mobile::serialization::Bool *>(default_value()) : nullptr;
  }
  const torch::jit::mobile::serialization::Double *default_value_as_Double() const {
    return default_value_type() == torch::jit::mobile::serialization::IValue_Double ? static_cast<const torch::jit::mobile::serialization::Double *>(default_value()) : nullptr;
  }
  const torch::jit::mobile::serialization::TensorMetadata *default_value_as_TensorMetadata() const {
    return default_value_type() == torch::jit::mobile::serialization::IValue_TensorMetadata ? static_cast<const torch::jit::mobile::serialization::TensorMetadata *>(default_value()) : nullptr;
  }
  const torch::jit::mobile::serialization::String *default_value_as_String() const {
    return default_value_type() == torch::jit::mobile::serialization::IValue_String ? static_cast<const torch::jit::mobile::serialization::String *>(default_value()) : nullptr;
  }
  const torch::jit::mobile::serialization::List *default_value_as_List() const {
    return default_value_type() == torch::jit::mobile::serialization::IValue_List ? static_cast<const torch::jit::mobile::serialization::List *>(default_value()) : nullptr;
  }
  const torch::jit::mobile::serialization::Tuple *default_value_as_Tuple() const {
    return default_value_type() == torch::jit::mobile::serialization::IValue_Tuple ? static_cast<const torch::jit::mobile::serialization::Tuple *>(default_value()) : nullptr;
  }
  const torch::jit::mobile::serialization::Dict *default_value_as_Dict() const {
    return default_value_type() == torch::jit::mobile::serialization::IValue_Dict ? static_cast<const torch::jit::mobile::serialization::Dict *>(default_value()) : nullptr;
  }
  const torch::jit::mobile::serialization::Object *default_value_as_Object() const {
    return default_value_type() == torch::jit::mobile::serialization::IValue_Object ? static_cast<const torch::jit::mobile::serialization::Object *>(default_value()) : nullptr;
  }
  const torch::jit::mobile::serialization::IntList *default_value_as_IntList() const {
    return default_value_type() == torch::jit::mobile::serialization::IValue_IntList ? static_cast<const torch::jit::mobile::serialization::IntList *>(default_value()) : nullptr;
  }
  const torch::jit::mobile::serialization::DoubleList *default_value_as_DoubleList() const {
    return default_value_type() == torch::jit::mobile::serialization::IValue_DoubleList ? static_cast<const torch::jit::mobile::serialization::DoubleList *>(default_value()) : nullptr;
  }
  const torch::jit::mobile::serialization::BoolList *default_value_as_BoolList() const {
    return default_value_type() == torch::jit::mobile::serialization::IValue_BoolList ? static_cast<const torch::jit::mobile::serialization::BoolList *>(default_value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyField<uint8_t>(verifier, VT_DEFAULT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_DEFAULT_VALUE) &&
           VerifyIValue(verifier, default_value(), default_value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const torch::jit::mobile::serialization::Int *Arg::default_value_as<torch::jit::mobile::serialization::Int>() const {
  return default_value_as_Int();
}

template<> inline const torch::jit::mobile::serialization::Bool *Arg::default_value_as<torch::jit::mobile::serialization::Bool>() const {
  return default_value_as_Bool();
}

template<> inline const torch::jit::mobile::serialization::Double *Arg::default_value_as<torch::jit::mobile::serialization::Double>() const {
  return default_value_as_Double();
}

template<> inline const torch::jit::mobile::serialization::TensorMetadata *Arg::default_value_as<torch::jit::mobile::serialization::TensorMetadata>() const {
  return default_value_as_TensorMetadata();
}

template<> inline const torch::jit::mobile::serialization::String *Arg::default_value_as<torch::jit::mobile::serialization::String>() const {
  return default_value_as_String();
}

template<> inline const torch::jit::mobile::serialization::List *Arg::default_value_as<torch::jit::mobile::serialization::List>() const {
  return default_value_as_List();
}

template<> inline const torch::jit::mobile::serialization::Tuple *Arg::default_value_as<torch::jit::mobile::serialization::Tuple>() const {
  return default_value_as_Tuple();
}

template<> inline const torch::jit::mobile::serialization::Dict *Arg::default_value_as<torch::jit::mobile::serialization::Dict>() const {
  return default_value_as_Dict();
}

template<> inline const torch::jit::mobile::serialization::Object *Arg::default_value_as<torch::jit::mobile::serialization::Object>() const {
  return default_value_as_Object();
}

template<> inline const torch::jit::mobile::serialization::IntList *Arg::default_value_as<torch::jit::mobile::serialization::IntList>() const {
  return default_value_as_IntList();
}

template<> inline const torch::jit::mobile::serialization::DoubleList *Arg::default_value_as<torch::jit::mobile::serialization::DoubleList>() const {
  return default_value_as_DoubleList();
}

template<> inline const torch::jit::mobile::serialization::BoolList *Arg::default_value_as<torch::jit::mobile::serialization::BoolList>() const {
  return default_value_as_BoolList();
}

struct ArgBuilder {
  typedef Arg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Arg::VT_NAME, name);
  }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Arg::VT_TYPE, type);
  }
  void add_default_value_type(torch::jit::mobile::serialization::IValue default_value_type) {
    fbb_.AddElement<uint8_t>(Arg::VT_DEFAULT_VALUE_TYPE, static_cast<uint8_t>(default_value_type), 0);
  }
  void add_default_value(flatbuffers::Offset<void> default_value) {
    fbb_.AddOffset(Arg::VT_DEFAULT_VALUE, default_value);
  }
  explicit ArgBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Arg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Arg>(end);
    return o;
  }
};

inline flatbuffers::Offset<Arg> CreateArg(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    torch::jit::mobile::serialization::IValue default_value_type = torch::jit::mobile::serialization::IValue_NONE,
    flatbuffers::Offset<void> default_value = 0) {
  ArgBuilder builder_(_fbb);
  builder_.add_default_value(default_value);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_default_value_type(default_value_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Arg> CreateArgDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *type = nullptr,
    torch::jit::mobile::serialization::IValue default_value_type = torch::jit::mobile::serialization::IValue_NONE,
    flatbuffers::Offset<void> default_value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  return torch::jit::mobile::serialization::CreateArg(
      _fbb,
      name__,
      type__,
      default_value_type,
      default_value);
}

struct Schema FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SchemaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARGUMENTS = 4,
    VT_RETURNS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Arg>> *arguments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Arg>> *>(VT_ARGUMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Arg>> *returns() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Arg>> *>(VT_RETURNS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARGUMENTS) &&
           verifier.VerifyVector(arguments()) &&
           verifier.VerifyVectorOfTables(arguments()) &&
           VerifyOffset(verifier, VT_RETURNS) &&
           verifier.VerifyVector(returns()) &&
           verifier.VerifyVectorOfTables(returns()) &&
           verifier.EndTable();
  }
};

struct SchemaBuilder {
  typedef Schema Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_arguments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Arg>>> arguments) {
    fbb_.AddOffset(Schema::VT_ARGUMENTS, arguments);
  }
  void add_returns(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Arg>>> returns) {
    fbb_.AddOffset(Schema::VT_RETURNS, returns);
  }
  explicit SchemaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Schema> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Schema>(end);
    return o;
  }
};

inline flatbuffers::Offset<Schema> CreateSchema(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Arg>>> arguments = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Arg>>> returns = 0) {
  SchemaBuilder builder_(_fbb);
  builder_.add_returns(returns);
  builder_.add_arguments(arguments);
  return builder_.Finish();
}

inline flatbuffers::Offset<Schema> CreateSchemaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<torch::jit::mobile::serialization::Arg>> *arguments = nullptr,
    const std::vector<flatbuffers::Offset<torch::jit::mobile::serialization::Arg>> *returns = nullptr) {
  auto arguments__ = arguments ? _fbb.CreateVector<flatbuffers::Offset<torch::jit::mobile::serialization::Arg>>(*arguments) : 0;
  auto returns__ = returns ? _fbb.CreateVector<flatbuffers::Offset<torch::jit::mobile::serialization::Arg>>(*returns) : 0;
  return torch::jit::mobile::serialization::CreateSchema(
      _fbb,
      arguments__,
      returns__);
}

struct DebugInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DebugInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEBUG_HANDLE = 4
  };
  const flatbuffers::Vector<int64_t> *debug_handle() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DEBUG_HANDLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DEBUG_HANDLE) &&
           verifier.VerifyVector(debug_handle()) &&
           verifier.EndTable();
  }
};

struct DebugInfoBuilder {
  typedef DebugInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_debug_handle(flatbuffers::Offset<flatbuffers::Vector<int64_t>> debug_handle) {
    fbb_.AddOffset(DebugInfo::VT_DEBUG_HANDLE, debug_handle);
  }
  explicit DebugInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DebugInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DebugInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<DebugInfo> CreateDebugInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> debug_handle = 0) {
  DebugInfoBuilder builder_(_fbb);
  builder_.add_debug_handle(debug_handle);
  return builder_.Finish();
}

inline flatbuffers::Offset<DebugInfo> CreateDebugInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *debug_handle = nullptr) {
  auto debug_handle__ = debug_handle ? _fbb.CreateVector<int64_t>(*debug_handle) : 0;
  return torch::jit::mobile::serialization::CreateDebugInfo(
      _fbb,
      debug_handle__);
}

struct Function FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FunctionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QN = 4,
    VT_INSTRUCTIONS = 6,
    VT_OPERATORS = 8,
    VT_CONSTANTS_TYPE = 10,
    VT_CONSTANTS = 12,
    VT_TYPES = 14,
    VT_REGISTER_SIZE = 16,
    VT_SCHEMA = 18,
    VT_DEBUG_INFO = 20
  };
  const flatbuffers::String *qn() const {
    return GetPointer<const flatbuffers::String *>(VT_QN);
  }
  const flatbuffers::Vector<const torch::jit::mobile::serialization::Instruction *> *instructions() const {
    return GetPointer<const flatbuffers::Vector<const torch::jit::mobile::serialization::Instruction *> *>(VT_INSTRUCTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Operator>> *operators() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Operator>> *>(VT_OPERATORS);
  }
  const flatbuffers::Vector<uint8_t> *constants_type() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONSTANTS_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<void>> *constants() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<void>> *>(VT_CONSTANTS);
  }
  const flatbuffers::Vector<uint8_t> *types() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_TYPES);
  }
  int32_t register_size() const {
    return GetField<int32_t>(VT_REGISTER_SIZE, 0);
  }
  const torch::jit::mobile::serialization::Schema *schema() const {
    return GetPointer<const torch::jit::mobile::serialization::Schema *>(VT_SCHEMA);
  }
  const torch::jit::mobile::serialization::DebugInfo *debug_info() const {
    return GetPointer<const torch::jit::mobile::serialization::DebugInfo *>(VT_DEBUG_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_QN) &&
           verifier.VerifyString(qn()) &&
           VerifyOffset(verifier, VT_INSTRUCTIONS) &&
           verifier.VerifyVector(instructions()) &&
           VerifyOffset(verifier, VT_OPERATORS) &&
           verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) &&
           VerifyOffset(verifier, VT_CONSTANTS_TYPE) &&
           verifier.VerifyVector(constants_type()) &&
           VerifyOffset(verifier, VT_CONSTANTS) &&
           verifier.VerifyVector(constants()) &&
           VerifyIValueVector(verifier, constants(), constants_type()) &&
           VerifyOffset(verifier, VT_TYPES) &&
           verifier.VerifyVector(types()) &&
           VerifyField<int32_t>(verifier, VT_REGISTER_SIZE) &&
           VerifyOffset(verifier, VT_SCHEMA) &&
           verifier.VerifyTable(schema()) &&
           VerifyOffset(verifier, VT_DEBUG_INFO) &&
           verifier.VerifyTable(debug_info()) &&
           verifier.EndTable();
  }
};

struct FunctionBuilder {
  typedef Function Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_qn(flatbuffers::Offset<flatbuffers::String> qn) {
    fbb_.AddOffset(Function::VT_QN, qn);
  }
  void add_instructions(flatbuffers::Offset<flatbuffers::Vector<const torch::jit::mobile::serialization::Instruction *>> instructions) {
    fbb_.AddOffset(Function::VT_INSTRUCTIONS, instructions);
  }
  void add_operators(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Operator>>> operators) {
    fbb_.AddOffset(Function::VT_OPERATORS, operators);
  }
  void add_constants_type(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> constants_type) {
    fbb_.AddOffset(Function::VT_CONSTANTS_TYPE, constants_type);
  }
  void add_constants(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> constants) {
    fbb_.AddOffset(Function::VT_CONSTANTS, constants);
  }
  void add_types(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> types) {
    fbb_.AddOffset(Function::VT_TYPES, types);
  }
  void add_register_size(int32_t register_size) {
    fbb_.AddElement<int32_t>(Function::VT_REGISTER_SIZE, register_size, 0);
  }
  void add_schema(flatbuffers::Offset<torch::jit::mobile::serialization::Schema> schema) {
    fbb_.AddOffset(Function::VT_SCHEMA, schema);
  }
  void add_debug_info(flatbuffers::Offset<torch::jit::mobile::serialization::DebugInfo> debug_info) {
    fbb_.AddOffset(Function::VT_DEBUG_INFO, debug_info);
  }
  explicit FunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Function> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Function>(end);
    return o;
  }
};

inline flatbuffers::Offset<Function> CreateFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> qn = 0,
    flatbuffers::Offset<flatbuffers::Vector<const torch::jit::mobile::serialization::Instruction *>> instructions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Operator>>> operators = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> constants_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<void>>> constants = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> types = 0,
    int32_t register_size = 0,
    flatbuffers::Offset<torch::jit::mobile::serialization::Schema> schema = 0,
    flatbuffers::Offset<torch::jit::mobile::serialization::DebugInfo> debug_info = 0) {
  FunctionBuilder builder_(_fbb);
  builder_.add_debug_info(debug_info);
  builder_.add_schema(schema);
  builder_.add_register_size(register_size);
  builder_.add_types(types);
  builder_.add_constants(constants);
  builder_.add_constants_type(constants_type);
  builder_.add_operators(operators);
  builder_.add_instructions(instructions);
  builder_.add_qn(qn);
  return builder_.Finish();
}

inline flatbuffers::Offset<Function> CreateFunctionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *qn = nullptr,
    const std::vector<torch::jit::mobile::serialization::Instruction> *instructions = nullptr,
    const std::vector<flatbuffers::Offset<torch::jit::mobile::serialization::Operator>> *operators = nullptr,
    const std::vector<uint8_t> *constants_type = nullptr,
    const std::vector<flatbuffers::Offset<void>> *constants = nullptr,
    const std::vector<uint8_t> *types = nullptr,
    int32_t register_size = 0,
    flatbuffers::Offset<torch::jit::mobile::serialization::Schema> schema = 0,
    flatbuffers::Offset<torch::jit::mobile::serialization::DebugInfo> debug_info = 0) {
  auto qn__ = qn ? _fbb.CreateString(qn) : 0;
  auto instructions__ = instructions ? _fbb.CreateVectorOfStructs<torch::jit::mobile::serialization::Instruction>(*instructions) : 0;
  auto operators__ = operators ? _fbb.CreateVector<flatbuffers::Offset<torch::jit::mobile::serialization::Operator>>(*operators) : 0;
  auto constants_type__ = constants_type ? _fbb.CreateVector<uint8_t>(*constants_type) : 0;
  auto constants__ = constants ? _fbb.CreateVector<flatbuffers::Offset<void>>(*constants) : 0;
  auto types__ = types ? _fbb.CreateVector<uint8_t>(*types) : 0;
  return torch::jit::mobile::serialization::CreateFunction(
      _fbb,
      qn__,
      instructions__,
      operators__,
      constants_type__,
      constants__,
      types__,
      register_size,
      schema,
      debug_info);
}

struct StorageData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StorageDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct StorageDataBuilder {
  typedef StorageData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(StorageData::VT_DATA, data);
  }
  explicit StorageDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StorageData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StorageData>(end);
    return o;
  }
};

inline flatbuffers::Offset<StorageData> CreateStorageData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  StorageDataBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<StorageData> CreateStorageDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  if (data) { _fbb.ForceVectorAlignment(data->size(), sizeof(uint8_t), 16); }
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return torch::jit::mobile::serialization::CreateStorageData(
      _fbb,
      data__);
}

struct Module FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModuleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHODS = 4,
    VT_TYPES = 6,
    VT_STATE_OBJ = 8,
    VT_STORAGE_DATA = 10,
    VT_STORAGE_DATA_SIZE = 12,
    VT_TYPE_ANNOTATIONS = 14
  };
  const flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Function>> *methods() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Function>> *>(VT_METHODS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::ObjectType>> *types() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::ObjectType>> *>(VT_TYPES);
  }
  const torch::jit::mobile::serialization::Object *state_obj() const {
    return GetPointer<const torch::jit::mobile::serialization::Object *>(VT_STATE_OBJ);
  }
  const flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::StorageData>> *storage_data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::StorageData>> *>(VT_STORAGE_DATA);
  }
  int32_t storage_data_size() const {
    return GetField<int32_t>(VT_STORAGE_DATA_SIZE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *type_annotations() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TYPE_ANNOTATIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.VerifyVectorOfTables(methods()) &&
           VerifyOffset(verifier, VT_TYPES) &&
           verifier.VerifyVector(types()) &&
           verifier.VerifyVectorOfTables(types()) &&
           VerifyOffset(verifier, VT_STATE_OBJ) &&
           verifier.VerifyTable(state_obj()) &&
           VerifyOffset(verifier, VT_STORAGE_DATA) &&
           verifier.VerifyVector(storage_data()) &&
           verifier.VerifyVectorOfTables(storage_data()) &&
           VerifyField<int32_t>(verifier, VT_STORAGE_DATA_SIZE) &&
           VerifyOffset(verifier, VT_TYPE_ANNOTATIONS) &&
           verifier.VerifyVector(type_annotations()) &&
           verifier.VerifyVectorOfStrings(type_annotations()) &&
           verifier.EndTable();
  }
};

struct ModuleBuilder {
  typedef Module Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_methods(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Function>>> methods) {
    fbb_.AddOffset(Module::VT_METHODS, methods);
  }
  void add_types(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::ObjectType>>> types) {
    fbb_.AddOffset(Module::VT_TYPES, types);
  }
  void add_state_obj(flatbuffers::Offset<torch::jit::mobile::serialization::Object> state_obj) {
    fbb_.AddOffset(Module::VT_STATE_OBJ, state_obj);
  }
  void add_storage_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::StorageData>>> storage_data) {
    fbb_.AddOffset(Module::VT_STORAGE_DATA, storage_data);
  }
  void add_storage_data_size(int32_t storage_data_size) {
    fbb_.AddElement<int32_t>(Module::VT_STORAGE_DATA_SIZE, storage_data_size, 0);
  }
  void add_type_annotations(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> type_annotations) {
    fbb_.AddOffset(Module::VT_TYPE_ANNOTATIONS, type_annotations);
  }
  explicit ModuleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Module> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Module>(end);
    return o;
  }
};

inline flatbuffers::Offset<Module> CreateModule(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::Function>>> methods = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::ObjectType>>> types = 0,
    flatbuffers::Offset<torch::jit::mobile::serialization::Object> state_obj = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<torch::jit::mobile::serialization::StorageData>>> storage_data = 0,
    int32_t storage_data_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> type_annotations = 0) {
  ModuleBuilder builder_(_fbb);
  builder_.add_type_annotations(type_annotations);
  builder_.add_storage_data_size(storage_data_size);
  builder_.add_storage_data(storage_data);
  builder_.add_state_obj(state_obj);
  builder_.add_types(types);
  builder_.add_methods(methods);
  return builder_.Finish();
}

inline flatbuffers::Offset<Module> CreateModuleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<torch::jit::mobile::serialization::Function>> *methods = nullptr,
    const std::vector<flatbuffers::Offset<torch::jit::mobile::serialization::ObjectType>> *types = nullptr,
    flatbuffers::Offset<torch::jit::mobile::serialization::Object> state_obj = 0,
    const std::vector<flatbuffers::Offset<torch::jit::mobile::serialization::StorageData>> *storage_data = nullptr,
    int32_t storage_data_size = 0,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *type_annotations = nullptr) {
  auto methods__ = methods ? _fbb.CreateVector<flatbuffers::Offset<torch::jit::mobile::serialization::Function>>(*methods) : 0;
  auto types__ = types ? _fbb.CreateVector<flatbuffers::Offset<torch::jit::mobile::serialization::ObjectType>>(*types) : 0;
  auto storage_data__ = storage_data ? _fbb.CreateVector<flatbuffers::Offset<torch::jit::mobile::serialization::StorageData>>(*storage_data) : 0;
  auto type_annotations__ = type_annotations ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*type_annotations) : 0;
  return torch::jit::mobile::serialization::CreateModule(
      _fbb,
      methods__,
      types__,
      state_obj,
      storage_data__,
      storage_data_size,
      type_annotations__);
}

inline bool VerifyIValue(flatbuffers::Verifier &verifier, const void *obj, IValue type) {
  switch (type) {
    case IValue_NONE: {
      return true;
    }
    case IValue_Int: {
      return verifier.Verify<torch::jit::mobile::serialization::Int>(static_cast<const uint8_t *>(obj), 0);
    }
    case IValue_Bool: {
      return verifier.Verify<torch::jit::mobile::serialization::Bool>(static_cast<const uint8_t *>(obj), 0);
    }
    case IValue_Double: {
      return verifier.Verify<torch::jit::mobile::serialization::Double>(static_cast<const uint8_t *>(obj), 0);
    }
    case IValue_TensorMetadata: {
      auto ptr = reinterpret_cast<const torch::jit::mobile::serialization::TensorMetadata *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case IValue_String: {
      auto ptr = reinterpret_cast<const torch::jit::mobile::serialization::String *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case IValue_List: {
      auto ptr = reinterpret_cast<const torch::jit::mobile::serialization::List *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case IValue_Tuple: {
      auto ptr = reinterpret_cast<const torch::jit::mobile::serialization::Tuple *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case IValue_Dict: {
      auto ptr = reinterpret_cast<const torch::jit::mobile::serialization::Dict *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case IValue_Object: {
      auto ptr = reinterpret_cast<const torch::jit::mobile::serialization::Object *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case IValue_IntList: {
      auto ptr = reinterpret_cast<const torch::jit::mobile::serialization::IntList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case IValue_DoubleList: {
      auto ptr = reinterpret_cast<const torch::jit::mobile::serialization::DoubleList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case IValue_BoolList: {
      auto ptr = reinterpret_cast<const torch::jit::mobile::serialization::BoolList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyIValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyIValue(
        verifier,  values->Get(i), types->GetEnum<IValue>(i))) {
      return false;
    }
  }
  return true;
}

inline const torch::jit::mobile::serialization::Module *GetModule(const void *buf) {
  return flatbuffers::GetRoot<torch::jit::mobile::serialization::Module>(buf);
}

inline const torch::jit::mobile::serialization::Module *GetSizePrefixedModule(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<torch::jit::mobile::serialization::Module>(buf);
}

inline bool VerifyModuleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<torch::jit::mobile::serialization::Module>(nullptr);
}

inline bool VerifySizePrefixedModuleBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<torch::jit::mobile::serialization::Module>(nullptr);
}

inline void FinishModuleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<torch::jit::mobile::serialization::Module> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedModuleBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<torch::jit::mobile::serialization::Module> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace serialization
}  // namespace mobile
}  // namespace jit
}  // namespace torch

#endif  // FLATBUFFERS_GENERATED_MOBILEBYTECODE_TORCH_JIT_MOBILE_SERIALIZATION_H_
