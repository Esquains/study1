from string import Template
import torch.tensortypes.nestedtensor.codegen as codegen
import argparse

def get_header():
    header = """
#include <torch/csrc/utils/pybind.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <ATen/ATen.h>

#include <vector>
#include <iostream>

namespace torch {
namespace tensortypes {
namespace nestedtensor {"""
    return header


def get_footer():
    footer = """
} // namespace nestedtensor
} // namespace tensortypes
} // namespace torch
"""
    return footer


def build_unary_functions():
    cpp_template = """
void nestedtensor_${op}(const std::vector<at::Tensor>& input1,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::${op}_out(out[i], input1[i]);
  }
}"""
    cpp_template = Template(cpp_template)
    cpp_source = ""
    for op in codegen.get_unary_functions():
        cpp_source += cpp_template.substitute(op=op)
    return cpp_source + "\n"

def build_binary_functions():
    cpp_template = """
void nestedtensor_${op}(const std::vector<at::Tensor>& input1,
                       const std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::${op}_out(out[i], input1[i], input2[i]);
  }
}"""
    cpp_template = Template(cpp_template)
    cpp_source = ""
    for op in codegen.get_binary_functions():
        cpp_source += cpp_template.substitute(op=op)
    return cpp_source + "\n"

def build_comparison_functions():
    cpp_template = """
void nestedtensor_${op}(const std::vector<at::Tensor>& input1,
                       const std::vector<at::Tensor>& input2,
                       std::vector<at::Tensor>& out) {
  for (int64_t i = 0; i < input1.size(); i++) {
    at::${op}_out(out[i], input1[i], input2[i]);
  }
}"""
    cpp_template = Template(cpp_template)
    cpp_source = ""
    for op in codegen.get_comparison_functions():
        cpp_source += cpp_template.substitute(op=op)
    return cpp_source + "\n"

def build_bindings():
    cpp_source = """
void add_nary_functions(py::module& m) {
"""

    pybind_template = '  m.def("${op}", &nestedtensor_${op}, "${op}");'
    pybind_template = Template(pybind_template)

    for op in codegen.get_unary_functions():
        cpp_source += pybind_template.substitute(op=op) + "\n"
    for op in codegen.get_binary_functions():
        cpp_source += pybind_template.substitute(op=op) + "\n"
    for op in codegen.get_comparison_functions():
        cpp_source += pybind_template.substitute(op=op) + "\n"
    cpp_source += """
}"""
    return cpp_source


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Generate tensor_list.cpp file')
    parser.add_argument('destination', 
                        help='The path to the file in which the cpp is to be stored')
    args = parser.parse_args()

    cpp_source = """// THIS CODE IS AUTOGENERATED! DO NOT MODIFY!
// The script is under
// torch/tensortypes/nestedtensor/codegen/nary_gen.py"""

    cpp_source += get_header()

    cpp_source += build_unary_functions()
    cpp_source += build_binary_functions()
    cpp_source += build_comparison_functions()

    cpp_source += build_bindings()

    cpp_source += get_footer()

    # TODO: Needs to happen in the build folder
    with open(args.destination, 'w') as source_out:
        source_out.write(cpp_source)
